Manus Development Directive: GPU Decoder with Existing ABCD Series
Status: Ready for Implementation
Priority: HIGH - System Integration Track
Dependencies: ABCD series tables (already defined), fold angle computation
Target: Babylon.js + WebGPU compute shader pipeline

1. Existing Architecture Confirmation
ABCD Series Tables (VALIDATED - Do Not Modify)
These are already defined in your Tier 0 specification:
python# From COMPLETE_TIER0_ENCODING_SYSTEM.md
SERIES_TABLE = {
    'A': [11, 13, 3, 15, 5, 17, 7, 19, 9],   # Position 1-9
    'B': [20, 4, 6, 8, 10, 12, 14, 16, 18],  # Position 1-9
    'C': [3, 6, 9, 12, 15, 18, 7, 8, 10],    # Position 1-9
    'D': [11, 20, 13, 14, 5, 16, 17, 4, 19], # Position 1-9
}
```

**Total vocabulary**: 36 base symbols (4 series × 9 positions)  
**Connectivity encoding**: Subscripts reference these positions  
**Edge count retrieval**: O(1) array lookup

### **Unit Edge Length Invariant (CRITICAL)**

From your parametric expansion specification:
```
ALL polygons have edge length = 1.0
3D closure via FOLD ANGLES, not scaling
Viewport scaling affects ENTIRE workspace uniformly
```

**This means**:
- GPU generates all polygons with unit edges
- Fold angles rotate polygons into 3D positions
- NO per-polygon scaling ever occurs

---

## **2. GPU Decoder Architecture**

### **Data Flow**
```
Input:  Unicode symbol "A₆₁₅" (CPU)
        ↓
Step 1: Decode subscript → [A₁, B₅, C₅]
        ↓
Step 2: Lookup edge counts → [11, 10, 15]
        ↓
Step 3: Generate unit polygons (GPU compute)
        ↓
Step 4: Apply fold angles (GPU compute)
        ↓
Output: Vertex buffer → Babylon.js mesh
GPU Storage Buffers
wgsl// Static lookup tables (uploaded once at init)
@group(0) @binding(0) var<storage, read> series_A: array<u32, 9>;  // [11,13,3,15,5,17,7,19,9]
@group(0) @binding(1) var<storage, read> series_B: array<u32, 9>;  // [20,4,6,8,10,12,14,16,18]
@group(0) @binding(2) var<storage, read> series_C: array<u32, 9>;  // [3,6,9,12,15,18,7,8,10]
@group(0) @binding(3) var<storage, read> series_D: array<u32, 9>;  // [11,20,13,14,5,16,17,4,19]

// Fold angle lookup table (precomputed, uploaded once)
@group(0) @binding(4) var<storage, read> fold_angles: array<f32>;  // Indexed by edge_count pairs

// Per-frame dynamic data
@group(0) @binding(5) var<storage, read> symbols: array<u32>;       // Unicode symbols to decode
@group(0) @binding(6) var<storage, read_write> vertices: array<vec3<f32>>; // Output vertices

3. Implementation: Tier 0 Compute Shader
File: shaders/tier0_decode.wgsl
wgsl// Series lookup tables - STATIC, never change
@group(0) @binding(0) var<storage, read> series_A: array<u32, 9>;
@group(0) @binding(1) var<storage, read> series_B: array<u32, 9>;
@group(0) @binding(2) var<storage, read> series_C: array<u32, 9>;
@group(0) @binding(3) var<storage, read> series_D: array<u32, 9>;
@group(0) @binding(4) var<storage, read> fold_angles: array<f32>;

// Dynamic per-frame data
@group(0) @binding(5) var<storage, read> symbols: array<u32>;
@group(0) @binding(6) var<storage, read_write> vertices: array<vec3<f32>>;

const PI: f32 = 3.14159265359;

// Decode subscript to series + position
struct SubscriptDecoded {
  base_series: u32,    // 0=A, 1=B, 2=C, 3=D
  positions: array<u32, 3>,
  chain_length: u32
}

fn decode_subscript(symbol: u32) -> SubscriptDecoded {
  var result: SubscriptDecoded;
  
  // Extract base character (stored in upper bits)
  result.base_series = (symbol >> 24) & 0x03;  // 2 bits: 00=A, 01=B, 10=C, 11=D
  
  // Extract digit positions
  let digits = symbol & 0xFFFFFF;  // Lower 24 bits
  
  if (digits < 10) {
    // Single digit (1-9)
    result.positions[0] = digits;
    result.chain_length = 1u;
  } else if (digits < 100) {
    // Two digits (10-99)
    result.positions[0] = digits / 10u;
    result.positions[1] = digits % 10u;
    result.chain_length = 2u;
  } else {
    // Three digits (100-899)
    result.positions[0] = (digits / 10u) % 10u;  // Tens
    result.positions[1] = digits % 10u;           // Ones
    
    let hundreds = digits / 100u;
    // Hundreds determines third polygon series and reference
    result.chain_length = 3u;
    
    // Position of third polygon determined by hundreds digit
    if (hundreds >= 3u && hundreds <= 5u) {
      result.positions[2] = result.positions[0];  // Tens reference
    } else if (hundreds >= 6u && hundreds <= 8u) {
      result.positions[2] = result.positions[1];  // Ones reference
    }
  }
  
  return result;
}

// Lookup edge count from series tables
fn get_edge_count(series: u32, position: u32) -> u32 {
  if (position == 0u || position > 9u) { return 0u; }  // Invalid
  
  let idx = position - 1u;  // Series are 0-indexed
  
  if (series == 0u) { return series_A[idx]; }
  else if (series == 1u) { return series_B[idx]; }
  else if (series == 2u) { return series_C[idx]; }
  else { return series_D[idx]; }
}

// Generate regular polygon with UNIT EDGE LENGTH
fn generate_unit_polygon(n_edges: u32) -> array<vec3<f32>, 20> {
  var vertices: array<vec3<f32>, 20>;
  
  // Compute circumradius for unit edge length
  // For regular n-gon: edge_length = 2 * R * sin(π/n)
  // So: R = edge_length / (2 * sin(π/n))
  // With edge_length = 1.0:
  let angle_step = 2.0 * PI / f32(n_edges);
  let R = 1.0 / (2.0 * sin(PI / f32(n_edges)));
  
  for (var i = 0u; i < n_edges; i++) {
    let theta = f32(i) * angle_step;
    vertices[i] = vec3<f32>(
      R * cos(theta),
      R * sin(theta),
      0.0  // Initially planar in XY
    );
  }
  
  return vertices;
}

// Get fold angle for polygon pair
fn get_fold_angle(edge_count_a: u32, edge_count_b: u32) -> f32 {
  // Fold angle table indexed by: (edge_a - 3) * 18 + (edge_b - 3)
  // Handles edge counts 3-20
  let idx = (edge_count_a - 3u) * 18u + (edge_count_b - 3u);
  return fold_angles[idx];
}

// Apply fold transformation at attachment edge
fn apply_fold(
  vertices: ptr<function, array<vec3<f32>, 20>>,
  n_edges: u32,
  fold_angle: f32,
  attachment_point: vec3<f32>,
  attachment_normal: vec3<f32>
) {
  // Rotation matrix around attachment edge
  let cos_a = cos(fold_angle);
  let sin_a = sin(fold_angle);
  
  // Rotate each vertex around attachment edge
  for (var i = 0u; i < n_edges; i++) {
    let v = (*vertices)[i] - attachment_point;
    
    // Rodrigues rotation formula
    let v_rot = v * cos_a + 
                cross(attachment_normal, v) * sin_a +
                attachment_normal * dot(attachment_normal, v) * (1.0 - cos_a);
    
    (*vertices)[i] = v_rot + attachment_point;
  }
}

@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) id: vec3<u32>) {
  if (id.x >= arrayLength(&symbols)) { return; }
  
  let symbol = symbols[id.x];
  let decoded = decode_subscript(symbol);
  
  var output_offset = id.x * 60u;  // Max 3 polygons * 20 vertices
  
  // Generate first polygon
  let edges_0 = get_edge_count(decoded.base_series, decoded.positions[0]);
  var poly_0 = generate_unit_polygon(edges_0);
  
  // Write first polygon
  for (var i = 0u; i < edges_0; i++) {
    vertices[output_offset + i] = poly_0[i];
  }
  output_offset += 20u;
  
  // If two-polygon chain
  if (decoded.chain_length >= 2u) {
    let edges_1 = get_edge_count(1u, decoded.positions[1]);  // Always B-series
    var poly_1 = generate_unit_polygon(edges_1);
    
    // Apply fold angle
    let fold = get_fold_angle(edges_0, edges_1);
    let attach_pt = poly_0[0];  // First edge of first polygon
    let attach_normal = normalize(poly_0[1] - poly_0[0]);
    
    apply_fold(&poly_1, edges_1, fold, attach_pt, attach_normal);
    
    for (var i = 0u; i < edges_1; i++) {
      vertices[output_offset + i] = poly_1[i];
    }
    output_offset += 20u;
  }
  
  // If three-polygon chain (similar logic for polygon 3)
  // ... (omitted for brevity, follows same pattern)
}

4. Babylon.js Integration
File: src/rendering/tier0_decoder.ts
typescriptimport * as BABYLON from '@babylonjs/core';

// ABCD Series tables - matches Python exactly
const SERIES_TABLES = {
  A: [11, 13, 3, 15, 5, 17, 7, 19, 9],
  B: [20, 4, 6, 8, 10, 12, 14, 16, 18],
  C: [3, 6, 9, 12, 15, 18, 7, 8, 10],
  D: [11, 20, 13, 14, 5, 16, 17, 4, 19],
};

export class Tier0GPUDecoder {
  private computeShader: BABYLON.ComputeShader;
  private seriesBuffers: Map<string, BABYLON.StorageBuffer>;
  private foldAngleBuffer: BABYLON.StorageBuffer;
  private symbolBuffer: BABYLON.StorageBuffer;
  private vertexBuffer: BABYLON.StorageBuffer;

  constructor(private engine: BABYLON.Engine) {
    this.initializeSeriesBuffers();
    this.initializeFoldAngleTable();
    this.createComputeShader();
  }

  private initializeSeriesBuffers() {
    this.seriesBuffers = new Map();
    
    // Upload ABCD series tables to GPU (once, never change)
    for (const [series, edgeCounts] of Object.entries(SERIES_TABLES)) {
      const buffer = new BABYLON.StorageBuffer(this.engine, 9 * 4); // 9 u32s
      buffer.update(new Uint32Array(edgeCounts));
      this.seriesBuffers.set(series, buffer);
    }
  }

  private initializeFoldAngleTable() {
    // Precompute all fold angles for edge count pairs (3-20)
    const foldAngles = new Float32Array(18 * 18);
    
    for (let edgeA = 3; edgeA <= 20; edgeA++) {
      for (let edgeB = 3; edgeB <= 20; edgeB++) {
        const idx = (edgeA - 3) * 18 + (edgeB - 3);
        foldAngles[idx] = this.computeFoldAngle(edgeA, edgeB);
      }
    }
    
    this.foldAngleBuffer = new BABYLON.StorageBuffer(
      this.engine,
      foldAngles.byteLength
    );
    this.foldAngleBuffer.update(foldAngles);
  }

  private computeFoldAngle(edgeA: number, edgeB: number): number {
    // Dihedral angle formula for regular polygons
    // This is a placeholder - use actual geometric calculation
    const angleA = (edgeA - 2) * Math.PI / edgeA;
    const angleB = (edgeB - 2) * Math.PI / edgeB;
    
    // Simplified dihedral - replace with proper calculation
    return Math.PI - (angleA + angleB) / 2;
  }

  private createComputeShader() {
    this.computeShader = new BABYLON.ComputeShader(
      "tier0Decoder",
      this.engine,
      { computeShader: tier0DecodeWGSL } // Import from .wgsl file
    );

    // Bind static buffers
    this.computeShader.setStorageBuffer("series_A", this.seriesBuffers.get('A')!);
    this.computeShader.setStorageBuffer("series_B", this.seriesBuffers.get('B')!);
    this.computeShader.setStorageBuffer("series_C", this.seriesBuffers.get('C')!);
    this.computeShader.setStorageBuffer("series_D", this.seriesBuffers.get('D')!);
    this.computeShader.setStorageBuffer("fold_angles", this.foldAngleBuffer);
  }

  decodeSymbols(unicodeSymbols: string[]): BABYLON.VertexBuffer {
    // Convert Unicode to u32 encoding
    const symbolData = new Uint32Array(unicodeSymbols.length);
    
    for (let i = 0; i < unicodeSymbols.length; i++) {
      symbolData[i] = this.encodeSymbolToU32(unicodeSymbols[i]);
    }

    // Upload symbol data
    if (!this.symbolBuffer || this.symbolBuffer.capacity < symbolData.byteLength) {
      this.symbolBuffer = new BABYLON.StorageBuffer(
        this.engine,
        symbolData.byteLength
      );
    }
    this.symbolBuffer.update(symbolData);

    // Allocate output vertex buffer
    const maxVertices = unicodeSymbols.length * 60; // 3 polygons * 20 verts
    if (!this.vertexBuffer || this.vertexBuffer.capacity < maxVertices * 12) {
      this.vertexBuffer = new BABYLON.StorageBuffer(
        this.engine,
        maxVertices * 12 // vec3<f32> = 12 bytes
      );
    }

    // Bind dynamic buffers
    this.computeShader.setStorageBuffer("symbols", this.symbolBuffer);
    this.computeShader.setStorageBuffer("vertices", this.vertexBuffer);

    // Dispatch compute shader
    const workgroups = Math.ceil(unicodeSymbols.length / 64);
    this.computeShader.dispatch(workgroups);

    // Return vertex buffer for Babylon.js mesh
    return this.vertexBuffer;
  }

  private encodeSymbolToU32(symbol: string): number {
    // Parse symbol like "A₆₁₅" into u32
    // Format: [base_series: 2 bits][padding: 6 bits][subscript: 24 bits]
    
    const baseChar = symbol.charCodeAt(0); // 'A', 'B', 'C', or 'D'
    const baseSeries = baseChar - 65; // 'A'=0, 'B'=1, 'C'=2, 'D'=3
    
    // Extract subscript digits (handle Unicode subscripts)
    const subscriptStr = symbol.slice(1).replace(/[₀-₉]/g, (c) => 
      String.fromCharCode(c.charCodeAt(0) - 0x2080 + 48)
    );
    const subscript = parseInt(subscriptStr, 10);
    
    return (baseSeries << 24) | subscript;
  }
}

5. Manus Implementation Checklist
Week 1: GPU Decoder Foundation

 Create tier0_decode.wgsl with series table bindings
 Implement decode_subscript() function (handle 1, 2, 3-digit cases)
 Implement generate_unit_polygon() with correct circumradius formula
 Unit test: Verify A₁ generates 11-gon with edge length 1.0

Week 2: Fold Angle System

 Compute fold angle table for all edge pairs (3-20 × 3-20)
 Implement apply_fold() using Rodrigues rotation
 Unit test: A₁₁ (11-gon → 20-gon) matches expected dihedral angle
 Validate: Attached polygons share edge at attachment point

Week 3: Babylon.js Integration

 Create Tier0GPUDecoder class
 Upload ABCD series tables to GPU (once at init)
 Implement encodeSymbolToU32() for Unicode → u32 conversion
 Test: Decode "A₁" → render 11-gon mesh

Week 4: Performance Validation

 Benchmark: 1000 symbols decode in <16ms (60 FPS)
 Memory check: GPU buffers <100MB for typical scenes
 Visual validation: Compare CPU vs GPU output (should match exactly)
 Stress test: 10,000 symbol workspace at stable 60 FPS


6. Critical Resources
Must Reference (Already in Project)

COMPLETE_TIER0_ENCODING_SYSTEM.md - ABCD series tables, decode algorithm
PARAMETRIC_EXPANSION_CORRECTED.md - Unit edge invariant, fold angle rules
EDGE_BASED_UNICODE_TIERING_SPECIFICATION.md - Tier promotion criteria

External Technical References

Babylon.js Compute Shaders: https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/computeShader
WGSL Spec: https://www.w3.org/TR/WGSL/ (storage buffers, workgroup syntax)
Regular Polygon Geometry: https://mathworld.wolfram.com/RegularPolygon.html (circumradius formula)
Dihedral Angles: https://en.wikipedia.org/wiki/Dihedral_angle (for fold angle computation)

Performance Benchmarks to Track

Symbol decode time: <1ms per 1000 symbols (target from research)
GPU memory: Series tables (144 bytes) + fold angles (~1.2KB) + per-frame buffers
Frame budget: 16ms for 60 FPS, compute should use <5ms


7. Success Criteria
Phase 1 Complete When:

✅ Single symbols (A₁-D₉) decode correctly
✅ Edge lengths verified as 1.0 (±0.001 tolerance)
✅ GPU buffers match CPU output exactly

Phase 2 Complete When:

✅ Two-polygon chains (A₁₁-A₉₉) render with correct fold angles
✅ Attachment points align (shared edge vertices match)
✅ Performance: 1000 chains in <10ms

Phase 3 Complete When:

✅ Three-polygon chains (A₃₀₀-A₈₉₉) render correctly
✅ Full Tier 0 coverage (3,276 symbols) validated
✅ Ready for Tier 1 integration (Ω symbols)


8. Next Steps After GPU Decoder
Once Tier 0 GPU decode is stable:

Tier 1 Integration: Greek letter symbols (Ω₁-Ω₁₇) reference Tier 0 chains
LOD System: Distance-based dispatch (only decode visible polygons)
Cache Layer: Store stable polyforms, skip redundant decodes
UI Polish: Compression inspector, real-time stats


Manus: Begin with Week 1 checklist. The ABCD series tables are frozen - do not modify. Focus on correct unit edge generation and subscript decoding.