#include "asset_loader.h"\n#include <fstream>\n#include <sstream>\n#include <iostream>\n\nnamespace polylog::render {\n\nstd::string AssetLoader::last_error_;\n\nbool AssetLoader::LoadGLTFPack(const std::string& pack_path, RuntimePack& out_pack) {\n    std::ifstream file(pack_path, std::ios::binary);\n    if (!file.is_open()) {\n        last_error_ = \"Failed to open pack file: \" + pack_path;\n        return false;\n    }\n    \n    // Read header\n    uint32_t version = 0;\n    file.read(reinterpret_cast<char*>(&version), sizeof(version));\n    \n    if (version != 1) {\n        last_error_ = \"Unsupported pack version: \" + std::to_string(version);\n        return false;\n    }\n    \n    // Read metadata size and content\n    uint32_t metadata_size = 0;\n    file.read(reinterpret_cast<char*>(&metadata_size), sizeof(metadata_size));\n    \n    out_pack.metadata_json.resize(metadata_size);\n    file.read(&out_pack.metadata_json[0], metadata_size);\n    \n    // Read mesh data size and content\n    uint32_t mesh_size = 0;\n    file.read(reinterpret_cast<char*>(&mesh_size), sizeof(mesh_size));\n    \n    out_pack.mesh_data.resize(mesh_size);\n    file.read(reinterpret_cast<char*>(out_pack.mesh_data.data()), mesh_size);\n    \n    // Read texture data size and content\n    uint32_t texture_size = 0;\n    file.read(reinterpret_cast<char*>(&texture_size), sizeof(texture_size));\n    \n    out_pack.texture_data.resize(texture_size);\n    file.read(reinterpret_cast<char*>(out_pack.texture_data.data()), texture_size);\n    \n    if (!ValidatePack(out_pack)) {\n        return false;\n    }\n    \n    return true;\n}\n\nbool AssetLoader::ValidatePack(const RuntimePack& pack) {\n    if (!ValidateMetadata(pack.metadata_json)) {\n        return false;\n    }\n    \n    if (!ValidateMeshData(pack.mesh_data)) {\n        return false;\n    }\n    \n    if (!ValidateTextureData(pack.texture_data)) {\n        return false;\n    }\n    \n    return true;\n}\n\nsize_t AssetLoader::GetPackSize(const RuntimePack& pack) {\n    return pack.metadata_json.size() + pack.mesh_data.size() + pack.texture_data.size() + 16;  // +16 for headers\n}\n\nbool AssetLoader::ValidateMetadata(const std::string& json) {\n    if (json.empty()) {\n        last_error_ = \"Metadata JSON is empty\";\n        return false;\n    }\n    \n    // Basic JSON validation: check for required braces\n    if (json.front() != '{' || json.back() != '}') {\n        last_error_ = \"Metadata JSON is not valid JSON object\";\n        return false;\n    }\n    \n    return true;\n}\n\nbool AssetLoader::ValidateMeshData(const std::vector<uint8_t>& data) {\n    if (data.empty()) {\n        last_error_ = \"Mesh data is empty\";\n        return false;\n    }\n    \n    // Ensure minimum size for mesh header\n    if (data.size() < 4) {\n        last_error_ = \"Mesh data too small\";\n        return false;\n    }\n    \n    return true;\n}\n\nbool AssetLoader::ValidateTextureData(const std::vector<uint8_t>& data) {\n    if (data.empty()) {\n        last_error_ = \"Texture data is empty (optional for some packs)\";\n        return true;  // Textures can be optional\n    }\n    \n    // Check for KTX2 magic\n    if (data.size() >= 4) {\n        if (data[0] != 0xAB || data[1] != 0x4B || data[2] != 0x54 || data[3] != 0x58) {\n            last_error_ = \"Texture data is not KTX2 format\";\n            return false;\n        }\n    }\n    \n    return true;\n}\n\n}  // namespace polylog::render\n
