#include "frame_logger.h"\n#include <iostream>\n#include <chrono>\n#include <fstream>\n\nnamespace polylog::core {\n\nthread_local FrameLogger* g_frame_logger = nullptr;\n\nFrameLogger& FrameLogger::Instance() {\n    if (!g_frame_logger) {\n        g_frame_logger = new FrameLogger();\n    }\n    return *g_frame_logger;\n}\n\nvoid FrameLogger::BeginFrame(uint32_t frame_number) {\n    current_metrics_ = FrameMetrics();\n    current_metrics_.frame_number = frame_number;\n    current_metrics_.timestamp_us = std::chrono::duration_cast<std::chrono::microseconds>(\n        std::chrono::system_clock::now().time_since_epoch()).count();\n}\n\nvoid FrameLogger::EndFrame() {\n    metrics_log_.push_back(current_metrics_);\n    \n    // Periodic publish (every 100 frames)\n    if (metrics_log_.size() % 100 == 0) {\n        PublishMetrics(metrics_endpoint_);\n    }\n}\n\nvoid FrameLogger::RecordMetric(const std::string& metric_name, float value) {\n    if (metric_name == \"cpu_ms\") {\n        current_metrics_.cpu_ms = value;\n    } else if (metric_name == \"gpu_ms\") {\n        current_metrics_.gpu_ms = value;\n    } else if (metric_name == \"draw_calls\") {\n        current_metrics_.draw_calls = static_cast<uint32_t>(value);\n    } else if (metric_name == \"dispatches\") {\n        current_metrics_.dispatches = static_cast<uint32_t>(value);\n    } else if (metric_name == \"vram_used\") {\n        current_metrics_.vram_used = static_cast<size_t>(value);\n    }\n}\n\nvoid FrameLogger::RecordPass(const std::string& pass_name, float duration_ms) {\n    // Simple accumulation; could be extended for per-pass breakdown\n    current_metrics_.cpu_ms += duration_ms;\n}\n\nvoid FrameLogger::PublishMetrics(const std::string& endpoint) {\n    if (endpoint.empty() || metrics_log_.empty()) {\n        return;\n    }\n    \n    // For now, just log to stdout. Could integrate with metrics backend.\n    std::cout << \"[Metrics] Published \" << metrics_log_.size() << \" frames to \" << endpoint << \"\\n\";\n    \n    // Example JSON line output (could go to HTTP endpoint)\n    for (const auto& metric : metrics_log_) {\n        std::cout << \"{\\\"frame\\\":\" << metric.frame_number \n                  << \",\\\"cpu_ms\\\":\" << metric.cpu_ms\n                  << \",\\\"gpu_ms\\\":\" << metric.gpu_ms\n                  << \",\\\"draws\\\":\" << metric.draw_calls\n                  << \"}\\n\";\n    }\n    \n    metrics_log_.clear();\n}\n\nvoid FrameLogger::ComputeFrameHash() {\n    // TODO: Compute hash of frame state for determinism verification\n}\n\n}  // namespace polylog::core\n