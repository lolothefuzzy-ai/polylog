#include <gtest/gtest.h>\n#include <iostream>\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/quaternion.hpp>\n#include <vector>\n#include <cmath>\n\n/**\n * VISUALIZATION TEST: Polygon and Polyform Instantiation & Rotation\n * \n * This test demonstrates:\n * 1. Creating polygon vertices and indices\n * 2. Instantiating 3D objects (cubes, pyramids) in workspace\n * 3. Applying rotations via quaternions and matrices\n * 4. Verifying geometric alignment and position transforms\n * 5. ASCII-art visualization of results\n */\n\nstruct Vertex {\n    glm::vec3 position;\n    glm::vec3 normal;\n    glm::vec2 texcoord;\n};\n\nstruct Mesh {\n    std::vector<Vertex> vertices;\n    std::vector<uint32_t> indices;\n    std::string name;\n};\n\nclass PolyformInstance {\npublic:\n    PolyformInstance(const std::string& name, const Mesh& mesh)\n        : name_(name), mesh_(mesh), position_(0, 0, 0), \n          rotation_(1, 0, 0, 0), scale_(1, 1, 1) {}\n    \n    void SetPosition(const glm::vec3& pos) { position_ = pos; }\n    void SetRotation(const glm::quat& rot) { rotation_ = glm::normalize(rot); }\n    void SetScale(const glm::vec3& scale) { scale_ = scale; }\n    \n    glm::mat4 GetTransformMatrix() const {\n        glm::mat4 model = glm::identity<glm::mat4>();\n        model = glm::translate(model, position_);\n        model *= glm::mat4_cast(rotation_);\n        model = glm::scale(model, scale_);\n        return model;\n    }\n    \n    glm::vec3 GetPosition() const { return position_; }\n    glm::quat GetRotation() const { return rotation_; }\n    glm::vec3 GetScale() const { return scale_; }\n    \n    /// Get transformed vertices for visualization\n    std::vector<glm::vec3> GetTransformedVertices() const {\n        glm::mat4 transform = GetTransformMatrix();\n        std::vector<glm::vec3> transformed;\n        \n        for (const auto& vertex : mesh_.vertices) {\n            glm::vec4 worldPos = transform * glm::vec4(vertex.position, 1.0f);\n            transformed.push_back(glm::vec3(worldPos));\n        }\n        \n        return transformed;\n    }\n    \n    std::string GetVisualization() const {\n        std::string vis = \"\\n=== Polyform: \" + name_ + \" ===\\n\";\n        vis += \"Position: (\" + std::to_string(position_.x) + \", \" \n            + std::to_string(position_.y) + \", \" + std::to_string(position_.z) + \")\\n\";\n        vis += \"Rotation: Q(\" + std::to_string(rotation_.x) + \", \" \n            + std::to_string(rotation_.y) + \", \" + std::to_string(rotation_.z) + \", \"\n            + std::to_string(rotation_.w) + \")\\n\";\n        vis += \"Scale: (\" + std::to_string(scale_.x) + \", \" \n            + std::to_string(scale_.y) + \", \" + std::to_string(scale_.z) + \")\\n\";\n        vis += \"\\nTriangles (\" + std::to_string(mesh_.indices.size() / 3) + \"):\";\n        \n        auto transformed = GetTransformedVertices();\n        for (size_t i = 0; i < mesh_.indices.size(); i += 3) {\n            uint32_t i0 = mesh_.indices[i];\n            uint32_t i1 = mesh_.indices[i + 1];\n            uint32_t i2 = mesh_.indices[i + 2];\n            \n            if (i0 < transformed.size() && i1 < transformed.size() && i2 < transformed.size()) {\n                vis += \"\\n  [\" + std::to_string(i / 3) + \"] V\" + std::to_string(i0) + \"(\" \n                    + std::to_string(transformed[i0].x) + \",\" + std::to_string(transformed[i0].y) + \",\" + std::to_string(transformed[i0].z) + \") -> V\" \n                    + std::to_string(i1) + \" -> V\" + std::to_string(i2);\n            }\n        }\n        \n        return vis;\n    }\n    \nprivate:\n    std::string name_;\n    Mesh mesh_;\n    glm::vec3 position_;\n    glm::quat rotation_;\n    glm::vec3 scale_;\n};\n\n// Create a unit cube mesh\nMesh CreateCubeMesh() {\n    Mesh cube;\n    cube.name = \"Cube\";\n    \n    // Vertices of a unit cube [-0.5, 0.5]\n    cube.vertices = {\n        // Front face\n        {glm::vec3(-0.5f, -0.5f,  0.5f), glm::vec3(0, 0, 1), glm::vec2(0, 0)},\n        {glm::vec3( 0.5f, -0.5f,  0.5f), glm::vec3(0, 0, 1), glm::vec2(1, 0)},\n        {glm::vec3( 0.5f,  0.5f,  0.5f), glm::vec3(0, 0, 1), glm::vec2(1, 1)},\n        {glm::vec3(-0.5f,  0.5f,  0.5f), glm::vec3(0, 0, 1), glm::vec2(0, 1)},\n        \n        // Back face\n        {glm::vec3( 0.5f, -0.5f, -0.5f), glm::vec3(0, 0, -1), glm::vec2(0, 0)},\n        {glm::vec3(-0.5f, -0.5f, -0.5f), glm::vec3(0, 0, -1), glm::vec2(1, 0)},\n        {glm::vec3(-0.5f,  0.5f, -0.5f), glm::vec3(0, 0, -1), glm::vec2(1, 1)},\n        {glm::vec3( 0.5f,  0.5f, -0.5f), glm::vec3(0, 0, -1), glm::vec2(0, 1)},\n    };\n    \n    // Indices (2 triangles per face, 6 faces)\n    cube.indices = {\n        0, 1, 2,  0, 2, 3,  // Front\n        4, 5, 6,  4, 6, 7,  // Back\n        5, 0, 3,  5, 3, 6,  // Left\n        1, 4, 7,  1, 7, 2,  // Right\n        3, 2, 7,  3, 7, 6,  // Top\n        5, 4, 1,  5, 1, 0,  // Bottom\n    };\n    \n    return cube;\n}\n\n// Create a pyramid mesh\nMesh CreatePyramidMesh() {\n    Mesh pyramid;\n    pyramid.name = \"Pyramid\";\n    \n    // Apex + base corners\n    pyramid.vertices = {\n        {glm::vec3(0.0f,  0.5f,  0.0f), glm::vec3(0, 1, 0), glm::vec2(0.5f, 0.5f)},  // Apex\n        {glm::vec3(-0.5f, -0.5f, -0.5f), glm::vec3(0, -1, 0), glm::vec2(0, 0)},     // Base\n        {glm::vec3( 0.5f, -0.5f, -0.5f), glm::vec3(0, -1, 0), glm::vec2(1, 0)},\n        {glm::vec3( 0.5f, -0.5f,  0.5f), glm::vec3(0, -1, 0), glm::vec2(1, 1)},\n        {glm::vec3(-0.5f, -0.5f,  0.5f), glm::vec3(0, -1, 0), glm::vec2(0, 1)},\n    };\n    \n    pyramid.indices = {\n        0, 1, 2,  0, 2, 3,  0, 3, 4,  0, 4, 1,  // Sides\n        1, 3, 2,  1, 4, 3,  // Base\n    };\n    \n    return pyramid;\n}\n\nclass GraphicsVisualizationTest : public ::testing::Test {\npublic:\n    void SetUp() override {\n        cube_mesh_ = CreateCubeMesh();\n        pyramid_mesh_ = CreatePyramidMesh();\n    }\n    \nprotected:\n    Mesh cube_mesh_;\n    Mesh pyramid_mesh_;\n};\n\n// TEST 1: Instantiate and display polygons\nTEST_F(GraphicsVisualizationTest, PolygonInstantiation) {\n    std::cout << \"\\n=== TEST: Polygon Instantiation ===\";\n    std::cout << \"\\nCube Mesh: \" << cube_mesh_.vertices.size() << \" vertices, \" \n              << cube_mesh_.indices.size() / 3 << \" triangles\";\n    std::cout << \"\\nPyramid Mesh: \" << pyramid_mesh_.vertices.size() << \" vertices, \" \n              << pyramid_mesh_.indices.size() / 3 << \" triangles\";\n    \n    EXPECT_EQ(cube_mesh_.vertices.size(), 8);\n    EXPECT_EQ(cube_mesh_.indices.size(), 36);  // 12 triangles * 3\n    EXPECT_EQ(pyramid_mesh_.vertices.size(), 5);\n    EXPECT_EQ(pyramid_mesh_.indices.size(), 18);  // 6 triangles * 3\n}\n\n// TEST 2: Create polyform instances\nTEST_F(GraphicsVisualizationTest, PolyformInstantiation) {\n    std::cout << \"\\n=== TEST: Polyform Instantiation ===\";\n    \n    PolyformInstance cube(\"Cube_1\", cube_mesh_);\n    PolyformInstance pyramid(\"Pyramid_1\", pyramid_mesh_);\n    \n    cube.SetPosition(glm::vec3(-2, 0, 0));\n    pyramid.SetPosition(glm::vec3(2, 0, 0));\n    \n    std::cout << cube.GetVisualization();\n    std::cout << pyramid.GetVisualization();\n    \n    EXPECT_EQ(cube.GetPosition(), glm::vec3(-2, 0, 0));\n    EXPECT_EQ(pyramid.GetPosition(), glm::vec3(2, 0, 0));\n}\n\n// TEST 3: Rotation transforms\nTEST_F(GraphicsVisualizationTest, PolyformRotation) {\n    std::cout << \"\\n=== TEST: Polyform Rotation ===\";\n    \n    PolyformInstance cube(\"Rotating_Cube\", cube_mesh_);\n    \n    // Rotate 90 degrees around X axis\n    glm::quat rot_x = glm::angleAxis(glm::radians(90.0f), glm::vec3(1, 0, 0));\n    cube.SetRotation(rot_x);\n    \n    // Rotate 45 degrees around Y axis\n    glm::quat rot_y = glm::angleAxis(glm::radians(45.0f), glm::vec3(0, 1, 0));\n    cube.SetRotation(rot_y);\n    \n    // Rotate 90 degrees around Z axis\n    glm::quat rot_z = glm::angleAxis(glm::radians(90.0f), glm::vec3(0, 0, 1));\n    cube.SetRotation(rot_z);\n    \n    std::cout << cube.GetVisualization();\n    \n    glm::quat result = cube.GetRotation();\n    EXPECT_NEAR(glm::length(result), 1.0f, 0.01f);  // Normalized\n}\n\n// TEST 4: Scale and combined transforms\nTEST_F(GraphicsVisualizationTest, PolyformScale) {\n    std::cout << \"\\n=== TEST: Polyform Scale & Combined Transform ===\";\n    \n    PolyformInstance cube(\"Scaled_Cube\", cube_mesh_);\n    PolyformInstance pyramid(\"Scaled_Pyramid\", pyramid_mesh_);\n    \n    // Cube: 2x scale, rotated 45 degrees around Y\n    cube.SetScale(glm::vec3(2, 2, 2));\n    cube.SetPosition(glm::vec3(-3, 1, 0));\n    cube.SetRotation(glm::angleAxis(glm::radians(45.0f), glm::vec3(0, 1, 0)));\n    \n    // Pyramid: 0.5x scale, rotated 30 degrees around Z\n    pyramid.SetScale(glm::vec3(0.5f, 0.5f, 0.5f));\n    pyramid.SetPosition(glm::vec3(3, -1, 0));\n    pyramid.SetRotation(glm::angleAxis(glm::radians(30.0f), glm::vec3(0, 0, 1)));\n    \n    std::cout << cube.GetVisualization();\n    std::cout << pyramid.GetVisualization();\n    \n    EXPECT_EQ(cube.GetScale(), glm::vec3(2, 2, 2));\n    EXPECT_EQ(pyramid.GetScale(), glm::vec3(0.5f, 0.5f, 0.5f));\n}\n\n// TEST 5: Workspace alignment verification\nTEST_F(GraphicsVisualizationTest, WorkspaceAlignment) {\n    std::cout << \"\\n=== TEST: Workspace Alignment Verification ===\";\n    \n    PolyformInstance cube(\"Cube_Grid\", cube_mesh_);\n    \n    // Create 3x3 grid of cubes\n    std::vector<PolyformInstance> grid;\n    for (int x = -1; x <= 1; ++x) {\n        for (int z = -1; z <= 1; ++z) {\n            PolyformInstance instance(\"Grid_\" + std::to_string(x) + \"_\" + std::to_string(z), cube_mesh_);\n            instance.SetPosition(glm::vec3(x * 2.0f, 0, z * 2.0f));\n            instance.SetRotation(glm::angleAxis(glm::radians(45.0f * (x + z)), glm::vec3(0, 1, 0)));\n            grid.push_back(instance);\n        }\n    }\n    \n    std::cout << \"\\nCreated \" << grid.size() << \" cubes in 3x3 grid\";\n    for (size_t i = 0; i < grid.size(); ++i) {\n        if (i % 3 == 0) std::cout << \"\\n\";\n        auto pos = grid[i].GetPosition();\n        std::cout << \"[\" << pos.x << \",\" << pos.z << \"] \";\n    }\n    \n    EXPECT_EQ(grid.size(), 9);\n    \n    // Verify each cube is in correct position\n    int idx = 0;\n    for (int x = -1; x <= 1; ++x) {\n        for (int z = -1; z <= 1; ++z) {\n            auto pos = grid[idx].GetPosition();\n            EXPECT_NEAR(pos.x, x * 2.0f, 0.01f);\n            EXPECT_NEAR(pos.z, z * 2.0f, 0.01f);\n            idx++;\n        }\n    }\n}\n\n// TEST 6: Transform matrix verification\nTEST_F(GraphicsVisualizationTest, TransformMatrixCorrectness) {\n    std::cout << \"\\n=== TEST: Transform Matrix Correctness ===\";\n    \n    PolyformInstance cube(\"Transform_Test_Cube\", cube_mesh_);\n    \n    glm::vec3 pos(5, 3, 2);\n    glm::quat rot = glm::angleAxis(glm::radians(90.0f), glm::vec3(0, 1, 0));\n    glm::vec3 scale(2, 2, 2);\n    \n    cube.SetPosition(pos);\n    cube.SetRotation(rot);\n    cube.SetScale(scale);\n    \n    glm::mat4 transform = cube.GetTransformMatrix();\n    \n    // Verify position component\n    EXPECT_NEAR(transform[3][0], pos.x, 0.01f);\n    EXPECT_NEAR(transform[3][1], pos.y, 0.01f);\n    EXPECT_NEAR(transform[3][2], pos.z, 0.01f);\n    \n    // Transform origin vertex and check result\n    glm::vec4 origin(0, 0, 0, 1);\n    glm::vec4 transformed = transform * origin;\n    EXPECT_NEAR(transformed.x, pos.x, 0.01f);\n    EXPECT_NEAR(transformed.y, pos.y, 0.01f);\n    EXPECT_NEAR(transformed.z, pos.z, 0.01f);\n    \n    std::cout << \"Transform matrix applied successfully\";\n}\n"