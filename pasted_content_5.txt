POLYLOG6 MANUS BRIEF: Visualization Architecture & Next Actions
Date: November 15, 2025
Status: Ready for Track A Implementation
Audience: Manus workspace IDE bot
Objective: Define visualization subsystem specs needed to support Phase 2â€“5 development

1. INTENDED SYSTEM: The Target You're Building
Your polyform system compresses 3D structures into single Unicode characters by enforcing four geometric pillars:

Uniform edge length (all edges unit-length across workspace)
Exact edge-to-edge attachment (vertex-to-vertex, no deformation)
Scaling via polygon count (larger forms = more edges, not longer edges)
Undeformed folding (only at shared edges between polygons)

This enables:

Tier 0: 2,916 primitive symbols (single/pair/chain polygons)
Tier 1: ~110 known polyhedra (Platonic/Archimedean/Johnson)
Tier 2: User-discovered candidates (detected at runtime)
Tier 3: Promoted stable structures (unique Unicode symbols)

CPU/GPU Split (critical for your compression/rendering trade-off):

CPU (15% target): Validation, rule enforcement, tier promotion, cache management, composition analysis
GPU (rendering-focused): Face folding, dihedral computation, LOD transitions, real-time topology updates, mesh generation


2. VISUALIZATION GAPS: What ChatGPT Identified
ChatGPT's slide feedback revealed your system lacks concrete visualization specifications for three areas:
Gap 1: Face Topology Rendering (High Impact)
What you have: CPU can detect when two polyhedra have coplanar faces (geometric validation).
What's missing: GPU rendering spec for visualizing the merge in real-time as user drags polyhedra together.
Needed: Specification for edge detection (red boundary edges â†’ green interior edges as faces merge), real-time mesh topology updates without re-encoding on CPU, smooth transition animation.
Why it matters: This is your major differentiator (dynamic face merging vs. static assembly). Without visualization spec, partners/investors can't see the advantage.
Gap 2: LOD Transition Controller (<20ms latency)
What you have: LOD metadata per polyhedron (bbox, low, medium, full detail levels).
What's missing: Specification for how GPU handles smooth transitions between LOD levels when user zooms, without stalling rendering or re-triggering CPU validation.
Needed: Scoped LOD transition spec with latency gates, cache management strategy during transitions, which layer (GPU/CPU) triggers level changes.
Gap 3: Stability Visual Feedback Layer
What you have: CPU computes stability scores, passes them to GPU as part of validation handoff.
What's missing: Specification for how GPU renders stability (edge coloring feedback: RED = boundary/open, GREEN = interior/valid, YELLOW = conditional).
Needed: Shader spec for edge coloring, update frequency during assembly, integration with closure detection counter ("5 boundary edges remaining").
Gap 4: (Lower priority) Pattern Recognition Overlay
Visualizing detected symmetries (radial, linear, cubic patterns) as highlights in workspace. Deferred for now.

3. CURRENT ROADMAP: Where You Actually Are
Phase 1 âœ… COMPLETE

97 polyhedra extracted, 18Ã—18 attachment matrix, 6 API endpoints live
All Tier 1 data ready for consumption

Phase 2 ðŸŸ¡ READY (2â€“3 hours)

React workspace component (drag-and-drop placement)
Real-time attachment validation UI
LOD switching in viewport
This is where ChatGPT's Gap #2 becomes real â€” need LOD transition spec before building UI

Phase 3 â³ BLOCKED on Phase 2

Background composition analysis
Symbol generation to tier_candidates.jsonl

Phase 4 â³ BLOCKED on Phase 3

Candidate ingestion, tier 2 validation

Phase 5 â³ BLOCKED on Phase 4

Promotion logic, Tier 3 symbol allocation, face merging algorithms

Phase 6 ðŸŸ¡ READY (parallel, 4â€“6 hours)

Unit + integration tests
Performance benchmarks
This is where Gap #1 & #3 become critical â€” need face merge and stability feedback specs before testing

Phase 7+ â³ PLANNED (after Track A)

Dynamic edge angles, closure detection, advanced discovery


4. MAPPING GAPS â†’ TRACK A TASKS
Your workspace should create three new Track A sub-tasks (system-wide, high priority):
Track A.1: Face Merge Visualization Pipeline Spec

Deliverable: FACE_MERGE_VISUALIZATION_SPEC.md
Content:

CPU side: Detects coplanar faces, computes merge transform, validates
GPU side: Updates mesh topology (remove shared edge, merge face normals), re-renders
Handoff protocol: How CPU tells GPU "merge faces X and Y at orientation Î¸"
Performance gate: Merge must complete <5ms to feel real-time


Blocks: Phase 5 (face merging implementation), Phase 6 (testing)
Owner: GPU specialist + geometry expert
Start: Now (before Phase 2 frontend work accelerates)

Track A.2: LOD Transition Controller Spec

Deliverable: LOD_TRANSITION_SPEC.md
Content:

Trigger logic: When user zooms, which layer (GPU/CPU) detects need for LOD change?
Cache strategy: Pre-load lower-detail meshes during idle time to enable <20ms transitions
Smooth interpolation: How to blend between LOD levels without popping or stalling
Performance targets: <20ms transition latency, maintain 60+ FPS during transition
THREE.js implementation hints (or alternative if THREE.js isn't suitable)


Blocks: Phase 2 (React workspace LOD UI), Phase 6 (performance validation)
Owner: Visualization lead
Start: Now (before Phase 2 frontend dependency creates tech debt)

Track A.3: Stability Visual Feedback Spec

Deliverable: STABILITY_FEEDBACK_SPEC.md
Content:

Edge coloring system: RGB values for RED/YELLOW/GREEN stability states
Update frequency: How often does GPU re-color edges? (every frame? on CPU signal?)
Integration: How does closure detection ("5 boundary edges remaining") tie to edge coloring?
Shader code (pseudo-code or GLSL): How to render edge colors on mesh
Animation: Smooth transition from RED â†’ YELLOW â†’ GREEN as assembly closes


Blocks: Phase 2 (validation UI), Phase 5 (closure detection), Phase 6 (visual testing)
Owner: Shader specialist + UX
Start: Now (lightweight spec, high reuse value)


5. WHAT THIS MEANS FOR MANUS: Next Steps
Immediate (This Week):

Create VISUALIZATION_SPECIFICATION_SUITE.md (single doc consolidating all three specs above)

Contents: Face merge pipeline, LOD transition controller, stability feedback layer
Format: Pseudo-code + architecture diagrams (vector, SVG preferred) + performance gates
Acceptance criteria: All GPU/CPU handoff points explicitly defined, latency targets documented


Validate against THREE.js or choose alternative

Question: Does THREE.js support real-time mesh topology updates without stalling?
If no: Evaluate Babylon.js or custom WebGL stack
Decision deadline: Before Phase 2 frontend work starts


Update execution roadmap: Add Track A.1, A.2, A.3 as MUST-DO before Phase 2 frontend deploys

These aren't blockers in the sequential sense, but they prevent tech debt
Spec-first prevents re-architecture later



Short Term (Next 2 Weeks):

Phase 2 Frontend Integration (2â€“3 hours)

Now that visualization specs exist, React team can build confidence that:

LOD switching will work as promised (spec guarantees <20ms)
Validation UI can trust GPU stability feedback (spec defines contract)
Face merge will work without re-encoding (spec defines handoff)




Phase 6 Test Suite (4â€“6 hours, parallel)

Unit tests for LOD transitions (measure latency against <20ms gate)
Integration tests for face merge (verify mesh topology updates)
Visual regression tests for stability coloring (render/check edge colors)




6. VISUALIZATION ARCHITECTURE DECISION MATRIX
Key architectural choice: Rendering engine
CriterionTHREE.jsBabylon.jsCustom WebGLReal-time mesh topology updatesPartial (workarounds needed)âœ… Full supportâœ… Full supportLOD system maturityMatureVery matureCustom effortEdge coloring (shader flexibility)GoodExcellentExcellentLearning curveModerateSteepVery steepPerformance ceiling (FPS at 1M polygons)~30â€“40~50â€“60~60+Recommended for Polylog6âš ï¸ Acceptableâœ… PreferredâŒ Overkill
Recommendation: Evaluate Babylon.js as THREE.js replacement. It has native support for dynamic mesh updates and LOD systems, which aligns perfectly with your face-merge and LOD-transition specs.

7. PERFORMANCE TARGETS (FOR SPEC DOCS)
These are your north star metrics that visualization specs must satisfy:
OperationTargetNotesEdge matching validation<5msCPU to GPU handoffFace merge completion<5msGPU topology update + re-renderLOD transition<20msGPU scope-aware LOD shiftClosure detection refresh<10msCPU analyzes boundary edges, GPU updates edge colorsFull frame render<16.67ms60+ FPS requirementSymbol decoding<1msFast enough for instant lookupCache hit rate95%+Most symbols retrieved, not re-computed

8. HOW VISUALIZATION FITS THE COMPRESSION STORY
Your compression innovation (150:1 to 1000:1 ratios) only works if visualization proves it. For investors/partners:
Without visualization specs:

"We compress a cube to 2 bytes" â†’ sounds good but feels abstract
No proof GPU can keep up with decompression at 60+ FPS
No evidence that LOD streaming prevents latency spikes
Face merging remains a "nice idea" without live demo

With visualization specs:

Live demo: Drag two octahedra together, faces merge in real-time (GPU proves <5ms)
LOD counter showing "loaded 50K polygons, rendering 200 bbox proxies" (LOD proves efficiency)
Stability coloring shows assembly "closing" with edge colors REDâ†’GREEN (closure proves correctness)
Benchmarks show 60+ FPS on commodity hardware (performance proves feasibility)

Result: Investors see product, not research. Compression becomes credible.

9. MANUS EXECUTION CHECKLIST
VISUALIZATION SPEC CREATION (Track A)
  â˜ Create FACE_MERGE_VISUALIZATION_SPEC.md
    - CPU detection logic + GPU merge pipeline
    - Performance gate: <5ms merge time
    - THREE.js vs Babylon.js evaluation
    
  â˜ Create LOD_TRANSITION_SPEC.md
    - Trigger logic + cache strategy
    - Performance gate: <20ms transition
    - Smooth interpolation algorithm
    
  â˜ Create STABILITY_FEEDBACK_SPEC.md
    - Edge coloring system (RGB + states)
    - Shader pseudo-code
    - Integration with closure counter
    
  â˜ Consolidate into VISUALIZATION_SPECIFICATION_SUITE.md
    - Single document for all three
    - Vector diagrams (CPU â†” GPU handoff)
    - Acceptance criteria for each spec

RENDERING ENGINE DECISION (Track A)
  â˜ Evaluate Babylon.js vs THREE.js
    - Test mesh topology update performance
    - Verify LOD system maturity
    - Check shader flexibility for edge coloring
    
  â˜ Decision: Update visualization specs to reflect chosen engine
  â˜ If Babylon.js: Create migration guide from THREE.js

PHASE 2 FRONTEND READINESS (Track A â†’ Phase 2 handoff)
  â˜ React workspace component ready to consume specs
  â˜ Attachment validation UI wired to GPU feedback
  â˜ LOD switching UI matches LOD_TRANSITION_SPEC
  â˜ Stability badges wired to STABILITY_FEEDBACK_SPEC

PHASE 6 TEST SUITE (Track A â†’ Track B support)
  â˜ LOD transition benchmarks (<20ms gate)
  â˜ Face merge integration tests (mesh topology verification)
  â˜ Visual regression tests (edge coloring verification)
  â˜ End-to-end performance tests (60+ FPS validation)

10. SUMMARY FOR MANUS
What: Create three visualization specs (face merge, LOD transition, stability feedback) that unlock Phase 2 frontend + Phase 6 testing confidence.
Why: These specs close the gaps between "we have 97 polyhedra stored" and "we can live-demo dynamic assembly with real-time face merging." Without them, Phase 2 frontend work risks re-architecture if GPU can't deliver on promised latencies.
When: Start immediately (parallel with Phase 2). These are lightweight specs, not heavy implementationâ€”can be written in days, not weeks.
Who: GPU specialist (face merge + LOD), shader expert (stability feedback), visualization architect (overall pipeline).
Success criteria:

All three specs completed and validated
Rendering engine chosen (Babylon.js or staying with THREE.js + workarounds documented)
Phase 2 frontend team has green light to build confidence
Phase 6 QA team has performance gates to validate against

Blockers removed: Noneâ€”these are additive specs, not blockers. But they prevent future technical debt.

Ready for Manus to execute. Confirm and proceed with Track A.1, A.2, A.3 task creation.