Got it. You're identifying a critical architectural correction. Let me reframe:
Current problem: Foundation as described was conflating two things:

Polygon placement (single polygon into workspace)
Polygon attachment (connecting edge-to-edge)

You're saying: Separate these concerns. Placement happens first (free placement on 2D base plane). Then attachment is the subsequent action (snapping edges when user chooses to connect).
This changes the execution path significantly. Before I rewrite the Foundation ‚Üí Phase 1‚Äì3 pipeline, three clarifying questions:

2D base plane behavior ‚Äì When user first places a polygon, does it land flat on a 2D grid (top-down view), and then folds into 3D as attachments occur? Or is the 2D plane just an organizational layer and the 3D workspace is where actual assembly happens?
Instance duplication ‚Äì You mentioned "CPU dealing with two instances per polygon." Are you saying:

Instance #1: The "template" from library (immutable, referenced by Unicode)
Instance #2: The "copy" placed in workspace (mutable position, can be selected/moved/connected)
And this distinction matters because Tier 2/3 polyforms also have this dual-instance pattern?


Edge snapping priority ‚Äì When user selects two open edges (one from Polygon A in workspace, one from Polygon B in library/workspace), should the snap:

Bring Polygon B into workspace automatically aligned to A?
Or require user to manually position B, then confirm snap?
And should rotation be constrained to valid dihedral angles, or free until snap confirmation?



These answers will reshape how Foundation ‚Üí Phase 1‚Äì3 actually structures polygon placement, attachment, and 2D‚Üî3D transitions.RetryLif we allow drag and drop from the library and within the workspace, then We would rotation to free until snap confirmation Snap should be dependent on free edges and save data based on our Unicode structure so that any given Poly form will allow snapping to available workspace polyforms or subforms that contain matching Polygon faces or edges for combination The instancing is a reference to the A B C and D Series for our Unicode indexing the way we want to think about this and feel free to try to make sense of this but by having different attachment sequences in unicode index we can pre warm the CPU with our attachments which gets progressively more powerful the more Unicode we save and commit four different attachment patterns scalars fold angles etc allowing us to drag and drop or move workspace polyform subforms to different locations within the total assembly the 2D plane behav should be like a 3D sandbox we'll assume that the 2D plane is the ground We start building on the ground and then when we can advance into 3D via folding we start to do so but we only go up into the current workspace This works even for spheroid shapes because as we get larger we can just resize the workspace moving the workspace Polygon up by a certain amount of units to be in the middle of the workspace instead of at the bottom So we start at the bottom in 2D then as we collect enough polygons to create 3D instances we build up into 3D and then as we save scalars to expand in 3D we move the workspace polyform to the middle of the workspace so that we can expand evenly across the circumference and surface area or linearly or in rings squares triangles any of the scalars that we've previously mentionedShow moreSynthesized architectural vision integrating drag-drop, Unicode attachment patterns, and progressive 3D assembly.The user is clarifying the architecture significantly. Let me parse what they're saying:

Drag-and-drop IS allowed - from library into workspace and within workspace itself
Series A/B/C/D instancing - refers to Unicode tier allocation strategies that pre-compute different attachment sequences/patterns
Key insight: Different Unicode indices store different attachment patterns, scalars, fold angles. This allows CPU pre-warming to work better as more Unicode is committed (more cached attachment patterns available).
2D‚Üí3D progression: Start building on 2D base plane (ground level). As assembly grows, fold into 3D. When save scalars (expand assembly), move workspace center up to keep assembly centered as it grows outward.
Workspace centering: For spheroid/radial growth, move the entire assembly up so it expands evenly around center, not just upward.

This is NOT asking for clarification - this is the user providing detailed architectural direction. I should:

Acknowledge the correct interpretation
Rewrite Foundation ‚Üí Phase 1-3 with this corrected understanding
Focus on the CPU pre-warming via Unicode attachment patterns as the core win
Structure it around: Drag-drop ‚Üí Free placement on 2D base ‚Üí Edge snapping triggers attachment ‚Üí 2D‚Üí3D folding ‚Üí Scalar expansion with workspace centering

The user is being very clear. I should NOT ask clarifying questions. I should rewrite the execution path with this understanding.Understood. This is the correct architecture. You're describing a progressive 2D‚Üí3D assembly system with Unicode-indexed attachment patterns as the pre-warming mechanism. Let me rewrite the entire Foundation ‚Üí Phase 1‚Äì3 path with this understanding:

CORRECTED EXECUTION PATH: Phases 1‚Äì3 with Unicode-Indexed Attachment Pre-Warming
Core Insight: Series A/B/C/D Unicode Indexing
Each Tier stores multiple Unicode indices for the same polyform, differentiated by which attachment sequences are active:
Symbol: Œ©‚ÇÖ‚ÇÄ (Octahedron)

Series A (Œ©‚ÇÖ‚ÇÄ·¥¨): All 12 edges available for attachment (unattached octahedron)
Series B (Œ©‚ÇÖ‚ÇÄ·¥Æ): 8 edges available (2 faces already merged)
Series C (Œ©‚ÇÖ‚ÇÄ·∂ú): 4 edges available (4 faces merged)
Series D (Œ©‚ÇÖ‚ÇÄ·¥∞): 0 edges available (closed, no further attachments)

Each series pre-computes:
- Which edges are available (open)
- Which Tier 0/1/2/3 symbols can snap to each edge
- Fold angles for each valid attachment
- Scaler factors (centroid-to-centroid displacement)
CPU pre-warming becomes exponentially more powerful as you commit more Unicode:
python# Minimal case: 18 Tier 0 primitives
attachment_cache_size = 18 * 4 series * 18 compatible_types ‚âà 1.3 KB

# After discovering Tier 1 (110 polyhedra)
attachment_cache_size = 110 * 4 * 110 ‚âà 48 KB

# After discovering Tier 2 (1000 user compounds)
attachment_cache_size = 1000 * 4 * 1000 ‚âà 4 MB (still tiny)

# All pre-computed, all accessible O(1)

FOUNDATION: Drag-Drop Assembly on 2D Base Plane (4‚Äì5 hours)
Architecture
pythonclass WorkspaceAssembly:
    """
    2D base plane (z=0) ‚Üí progressive 3D folding ‚Üí scalar expansion with centering
    """
    
    def __init__(self):
        self.base_plane_z = 0.0  # Ground level
        self.workspace_center_z = 0.0  # Moves up as assembly expands
        
        # Instance management
        self.templates = {}  # Unicode symbol ‚Üí immutable Tier geometry
        self.instances = {}  # instance_id ‚Üí mutable workspace instance
        
        # Attachment tracking
        self.liaison_graph = {}  # instance_id ‚Üí connected instances + edge pairs
        self.open_edges = {}  # (instance_id, edge_idx) ‚Üí available for snapping
    
    def drag_polygon_from_library(self, unicode_symbol):
        """
        User drags polygon from library (sidebar).
        Returns instance handle for placement.
        """
        # Step 1: Fetch template (immutable)
        template = self.templates[unicode_symbol]
        
        # Step 2: Create workspace instance (mutable copy)
        instance_id = f"inst_{next_id}"
        instance = {
            'unicode_symbol': unicode_symbol,
            'series': 'A',  # All edges available initially
            'position': [0, 0, 0],  # Will be set by user drag
            'rotation': Quaternion.identity(),
            'vertices': template.vertices.copy(),
            'faces': template.faces.copy(),
            'edges': template.edges.copy(),  # All marked as open
        }
        self.instances[instance_id] = instance
        
        return instance_id
    
    def place_on_base_plane(self, instance_id, x, y):
        """
        User drops polygon on 2D base plane.
        Polygon lands flat (z=0) at (x, y, 0).
        """
        instance = self.instances[instance_id]
        instance['position'] = [x, y, self.base_plane_z]
        instance['rotation'] = Quaternion.from_euler(0, 0, 0)  # No rotation initially
        
        # Step 1: Register all edges as open
        for edge_idx, edge in enumerate(instance['edges']):
            edge_key = (instance_id, edge_idx)
            
            # Query: which other instances have compatible edges?
            compatible = self.find_compatible_edges(instance_id, edge_idx)
            
            self.open_edges[edge_key] = {
                'instance_id': instance_id,
                'edge_idx': edge_idx,
                'compatible_with': compatible,  # Pre-computed via Unicode
                'position': self.compute_edge_midpoint_3d(instance, edge),
                'normal': self.compute_edge_normal(instance, edge),
            }
        
        # Step 2: Update HUD
        self.update_hud(f"Placed {instance['unicode_symbol']} at ({x}, {y})")
    
    def find_compatible_edges(self, instance_id_a, edge_idx_a):
        """
        O(1) lookup: which edges in workspace can snap to this edge?
        
        Uses Series A/B/C/D Unicode index pre-computation.
        """
        instance_a = self.instances[instance_a]
        unicode_a = instance_a['unicode_symbol']
        series_a = instance_a['series']
        
        # Fetch pre-computed attachment data
        attachment_key = (unicode_a, series_a, edge_idx_a)
        compatible_types = self.cpu_attachment_cache[attachment_key]
        # Returns: [(unicode_b, edge_idx_b, fold_angle, scaler), ...]
        
        # Find all workspace instances matching compatible types
        compatible_edges = []
        for instance_id_b, instance_b in self.instances.items():
            if instance_id_b == instance_id_a:
                continue
            
            unicode_b = instance_b['unicode_symbol']
            series_b = instance_b['series']
            
            for (comp_unicode, comp_edge_idx, fold_angle, scaler) in compatible_types:
                if comp_unicode == unicode_b:
                    # This edge pair can snap
                    compatible_edges.append({
                        'instance_id': instance_id_b,
                        'edge_idx': comp_edge_idx,
                        'fold_angle': fold_angle,
                        'scaler': scaler,
                    })
        
        return compatible_edges  # O(1) cache lookups, O(N) list construction (N=workspace instances)
GPU Rendering: 2D Base Plane + Free Rotation
glsl// Babylon.js scene setup

void render_assembly() {
    // Render base plane (z=0)
    render_grid_plane(width=100, height=100, z=0);
    
    // Render all instances
    for each instance in workspace.instances {
        // Fetch template geometry (pre-loaded in GPU)
        mesh = gpu_polygon_cache[instance.unicode_symbol];
        
        // Apply instance transform
        transform = compute_transform(
            position=instance.position,
            rotation=instance.rotation
        );
        
        // Color edges
        for each edge in instance.edges {
            if edge.is_open:
                color = RED;  // Available for snapping
            else:
                color = GREEN;  // Attached
        }
        
        mesh.position = transform.position;
        mesh.rotationQuaternion = transform.rotation;
        scene.addMesh(mesh);
    }
    
    // Render snap zones (transparent, interactive)
    for each open_edge in workspace.open_edges {
        snap_zone = create_cylinder(
            position=open_edge.position,
            direction=open_edge.normal,
            radius=0.3,
            height=0.1,
            material=TRANSPARENT_GREEN
        );
        snap_zone.isPickable = true;
        snap_zone.data = {instance_id, edge_idx};  // Link back to data
    }
}

// User input: free rotation while dragging
void on_pointer_move(event) {
    if (dragging_instance) {
        // Compute rotation delta from mouse movement
        delta_x = event.clientX - last_x;
        delta_y = event.clientY - last_y;
        
        // Apply rotation (Euler angles, free until snap)
        instance.rotation *= Quaternion.from_euler(
            rx=delta_y * 0.01,
            ry=delta_x * 0.01,
            rz=0
        );
        
        // Update snap zones for this instance (moved geometry)
        for each edge in instance.edges {
            edge.position = compute_edge_midpoint_3d(instance, edge);
            snap_zone[edge].position = edge.position;
        }
    }
}
Snapping Mechanism: Edge-Aware Attachment
pythondef snap_edges(self, instance_id_a, edge_idx_a, instance_id_b, edge_idx_b):
    """
    User confirms snap between two edges.
    Compute attachment transform and update 3D positions.
    """
    instance_a = self.instances[instance_id_a]
    instance_b = self.instances[instance_id_b]
    
    # Step 1: Fetch pre-computed attachment data
    unicode_a = instance_a['unicode_symbol']
    unicode_b = instance_b['unicode_symbol']
    
    attachment_key = (unicode_a, edge_idx_a, unicode_b, edge_idx_b)
    attachment_data = self.cpu_attachment_cache[attachment_key]
    # Returns: {fold_angle, centroid_displacement, scaler, axis}
    
    fold_angle = attachment_data['fold_angle']
    centroid_disp = attachment_data['centroid_displacement']
    hinge_axis = attachment_data['hinge_axis']
    
    # Step 2: Compute rotation needed to align edges
    edge_a = instance_a['edges'][edge_idx_a]
    edge_b = instance_b['edges'][edge_idx_b]
    
    # Compute rotation around hinge (shared edge)
    rotation_to_fold = Quaternion.from_axis_angle(
        axis=hinge_axis,
        angle=fold_angle
    )
    
    # Step 3: Update instance B position and rotation
    instance_b['rotation'] *= rotation_to_fold
    instance_b['position'] += centroid_disp
    
    # Step 4: Mark edges as attached (update series)
    instance_a['edges'][edge_idx_a]['attached'] = True
    instance_b['edges'][edge_idx_b]['attached'] = True
    
    # Step 5: Update series (fewer available edges)
    # If instance now has all edges attached ‚Üí series D
    # If half attached ‚Üí series B/C
    new_series = self.compute_series_from_edges(instance_a)
    instance_a['series'] = new_series
    
    # Step 6: Update liaison graph
    self.liaison_graph[(instance_id_a, instance_id_b)] = {
        'edge_a': edge_idx_a,
        'edge_b': edge_idx_b,
        'fold_angle': fold_angle,
    }
    
    # Step 7: Remove from open_edges registry
    del self.open_edges[(instance_id_a, edge_idx_a)]
    del self.open_edges[(instance_id_b, edge_idx_b)]
    
    # Step 8: GPU animation
    gpu_fold_animation = {
        'instance_id': instance_id_b,
        'start_rotation': instance_b['rotation'],
        'end_rotation': instance_b['rotation'] * rotation_to_fold,
        'duration': 0.5,  # 500ms fold animation
    }
    self.gpu_queue.put(gpu_fold_animation)
2D‚Üí3D Transition: Progressive Folding
pythondef on_fold_animation_complete(self, instance_id):
    """
    After edge snap animation completes, check if assembly is rising into 3D.
    """
    instance = self.instances[instance_id]
    
    # Step 1: Check if any vertices have moved above base plane (z > 0.1)
    max_z = max([v[2] for v in instance['vertices']])
    
    if max_z > 0.1:
        # Assembly is folding into 3D
        print(f"Assembly rising into 3D at z={max_z}")
        
        # Step 2: Update open edge positions (now in 3D space)
        for edge_idx in range(len(instance['edges'])):
            if not instance['edges'][edge_idx]['attached']:
                edge_key = (instance_id, edge_idx)
                self.open_edges[edge_key]['position'] = self.compute_edge_midpoint_3d(
                    instance, instance['edges'][edge_idx]
                )
                self.open_edges[edge_key]['normal'] = self.compute_edge_normal(instance, edge_idx)
    
    # Step 3: If assembly now has 0 boundary edges ‚Üí closed
    if len([e for e in instance['edges'] if not e['attached']]) == 0:
        self.on_assembly_closed(instance_id)
Workspace Centering: Scalar Expansion
pythondef expand_assembly_via_scalar(self, instance_id, scalar_factor):
    """
    User applies scalar to assembly (2x growth, 3x growth, etc.).
    Move entire assembly up and outward.
    """
    instance = self.instances[instance_id]
    
    # Step 1: Compute bounding box before scaling
    bb_min, bb_max = self.compute_bounding_box(instance)
    bb_center = (bb_min + bb_max) / 2
    bb_height = bb_max[2] - bb_min[2]
    
    # Step 2: Scale vertices around bounding box center
    for vertex in instance['vertices']:
        vertex_relative = vertex - bb_center
        vertex_relative *= scalar_factor
        vertex = bb_center + vertex_relative
    
    # Step 3: Move entire assembly up so bounding box is centered in workspace
    new_bb_min, new_bb_max = self.compute_bounding_box(instance)
    new_height = new_bb_max[2] - new_bb_min[2]
    
    # Move up so assembly is centered vertically in workspace
    target_z = self.workspace_center_z - (new_height / 2)
    z_offset = target_z - instance['position'][2]
    instance['position'][2] += z_offset
    
    # Step 4: GPU re-renders at new position/scale
    gpu_update = {
        'instance_id': instance_id,
        'new_position': instance['position'],
        'new_vertices': instance['vertices'],  # scaled
    }
    self.gpu_queue.put(gpu_update)
    
    print(f"Assembly expanded by {scalar_factor}x, centered at z={self.workspace_center_z}")
Deliverable after Foundation (4‚Äì5 hours)

‚úÖ Babylon.js scene with 2D base plane (z=0)
‚úÖ Drag-and-drop polygon placement from library
‚úÖ Free rotation while dragging (mouse delta ‚Üí Euler)
‚úÖ Snap zones render as transparent cylinders at open edges
‚úÖ Edge snapping triggers fold animation (rotation around hinge)
‚úÖ Assembly progressively folds into 3D as edges attach
‚úÖ Open edge registry updates in real-time
‚úÖ HUD shows open edge count + attachment status
‚úÖ Workspace centering moves assembly up as it expands


PHASE 1: CPU Pre-Warming via Unicode Attachment Cache (3‚Äì4 hours)
Series A/B/C/D Pre-Computation
pythonclass UnicodeCacheWarmupEngine:
    """
    Pre-compute attachment patterns for all Unicode indices (A/B/C/D series).
    CPU warms these caches as soon as Unicode is committed.
    """
    
    def __init__(self):
        self.attachment_cache = {}  # (unicode, series, edge_idx) ‚Üí compatible edges
    
    def warm_tier_0(self):
        """Pre-compute Series A/B/C/D for all 18 primitives."""
        for unicode_symbol in ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R']:
            primitive = load_primitive(unicode_symbol)
            
            for series in ['A', 'B', 'C', 'D']:
                # Determine which edges are open in this series
                open_edges = self.determine_open_edges_for_series(primitive, series)
                
                for edge_idx in open_edges:
                    # For each open edge, find all compatible attachment targets
                    compatible = self.find_compatible_attachments(primitive, edge_idx)
                    
                    cache_key = (unicode_symbol, series, edge_idx)
                    self.attachment_cache[cache_key] = compatible
    
    def warm_tier_1(self):
        """Pre-compute Series A/B/C/D for all 110 Tier 1 polyhedra."""
        for unicode_symbol in tier1_library:
            polyhedron = load_polyhedron(unicode_symbol)
            
            for series in ['A', 'B', 'C', 'D']:
                open_edges = self.determine_open_edges_for_series(polyhedron, series)
                
                for edge_idx in open_edges:
                    compatible = self.find_compatible_attachments(polyhedron, edge_idx)
                    
                    cache_key = (unicode_symbol, series, edge_idx)
                    self.attachment_cache[cache_key] = compatible
    
    def warm_tier_2_incremental(self, new_unicode_symbol):
        """
        When user discovers new Tier 2 polyform, immediately compute Series A/B/C/D.
        This happens asynchronously (doesn't block GPU).
        """
        polyform = load_tier2_polyform(new_unicode_symbol)
        
        for series in ['A', 'B', 'C', 'D']:
            open_edges = self.determine_open_edges_for_series(polyform, series)
            
            for edge_idx in open_edges:
                compatible = self.find_compatible_attachments(polyform, edge_idx)
                
                cache_key = (new_unicode_symbol, series, edge_idx)
                self.attachment_cache[cache_key] = compatible
        
        print(f"Warmed cache for {new_unicode_symbol}: {len(self.attachment_cache)} entries")
Async Pre-Warming During Workspace Build
pythonclass AsyncCPUPipeline:
    """
    Runs parallel to GPU rendering.
    Pre-warms attachment cache for likely next placements.
    """
    
    def __init__(self, cache_engine):
        self.cache_engine = cache_engine
        self.task_queue = asyncio.Queue()
    
    async def predict_and_warm(self, current_assembly):
        """
        Predict which polyforms user might add next.
        Pre-compute their Series A/B/C/D attachment patterns.
        """
        # Step 1: Analyze current assembly
        used_symbols = [inst['unicode_symbol'] for inst in current_assembly.instances.values()]
        
        # Step 2: Heuristic: predict next placements
        # (1) Recent history (what user just placed)
        # (2) Tier 0 primitives (always likely)
        # (3) Tier 1 compatible with current assembly symmetry
        candidates = self.predict_next_candidates(used_symbols, current_assembly)
        
        # Step 3: Warm cache for each candidate
        for candidate_unicode in candidates:
            if candidate_unicode not in self.cache_engine.attachment_cache:
                # Asynchronously warm
                await self.task_queue.put(('warm_symbol', candidate_unicode))
                
                # Process (doesn't block GPU)
                self.cache_engine.warm_tier_2_incremental(candidate_unicode)
    
    def predict_next_candidates(self, used_symbols, assembly):
        """
        Heuristic prediction (can be refined over time).
        """
        candidates = []
        
        # Always include Tier 0
        candidates.extend(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R'])
        
        # Include most recently placed
        if used_symbols:
            candidates.append(used_symbols[-1])
        
        # Include high-frequency Tier 1 (cubes, tetrahedra, octahedra)
        candidates.extend(['Œ©‚ÇÅ', 'Œ©‚ÇÇ', 'Œ©‚ÇÉ'])  # Pre-defined high-value symbols
        
        return list(set(candidates))  # Deduplicate
GPU Benefit: Instant Snap Response
glsl// GPU polling for pre-warmed attachments (O(1) cache hits)

void on_edge_snap_attempt(instance_a, edge_a, instance_b, edge_b) {
    // CPU has pre-computed this attachment (likely)
    attachment_data = cpu_attachment_cache[(instance_a.unicode, edge_a, instance_b.unicode, edge_b)];
    
    if (attachment_data != null) {
        // Cache hit! Render immediately
        fold_angle = attachment_data.fold_angle;
        render_fold_animation(instance_b, fold_angle);
    } else {
        // Cache miss (unusual polyform)
        // Compute attachment on-demand (takes <5ms)
        attachment_data = compute_attachment(instance_a, edge_a, instance_b, edge_b);
        render_fold_animation(instance_b, attachment_data.fold_angle);
    }
}
Deliverable after Phase 1 (3‚Äì4 hours)

‚úÖ Series A/B/C/D pre-computation for Tier 0, 1
‚úÖ Attachment cache grows with each new Tier 2 discovery
‚úÖ Async CPU pipeline predicts next candidates
‚úÖ GPU polls cache, gets O(1) attachment data (99%+ hit rate)
‚úÖ Snap response <50ms (includes animation)
‚úÖ HUD displays cache size + hit rate metrics


PHASE 2: Face Pruning + Unicode Symbol Allocation (4‚Äì5 hours)
Closure Detection + Face Merge
pythonclass FacePruningEngine:
    """
    When assembly has 0 boundary edges ‚Üí trigger face merge.
    GPU executes merge, CPU allocates new Unicode symbol.
    """
    
    def on_assembly_closed(self, assembly, instance_id):
        """Triggered when boundary_edge_count == 0."""
        
        # Step 1: Extract composition (which Unicode symbols were used)
        composition = []
        for inst_id, instance in assembly.instances.items():
            composition.append(instance['unicode_symbol'])
        
        composition_hash = hash(sorted(composition))
        
        # Step 2: Check if this composition is known
        if composition_hash in tier2_registry:
            new_symbol = tier2_registry[composition_hash]
            print(f"Composition known: {new_symbol}")
        else:
            # Step 3: Allocate new Tier 2 symbol
            new_symbol = allocator.allocate_symbol(
                category='user_cluster',
                metadata={
                    'composition': composition,
                    'instances': {id: inst['unicode_symbol'] for id, inst in assembly.instances.items()},
                }
            )
            tier2_registry[composition_hash] = new_symbol
            print(f"New polyform discovered: {new_symbol}")
        
        # Step 4: Extract merged face topology + new attachment patterns
        merged_topology = self.compute_merged_topology(assembly)
        new_attachment_patterns = self.extract_new_attachment_patterns(merged_topology)
        
        # Step 5: GPU executes face merge
        gpu_merge_command = {
            'action': 'execute_face_merge',
            'assembly': assembly,
            'result_symbol': new_symbol,
            'new_topology': merged_topology,
        }
        assembly.gpu_queue.put(gpu_merge_command)
        
        # Step 6: Warm cache for new symbol (async)
        asyncio.create_task(self.warm_new_symbol(new_symbol, new_attachment_patterns))
    
    def compute_merged_topology(self, assembly):
        """
        Identify coplanar faces that should merge.
        """
        merged_faces = []
        
        for (inst_a, inst_b), edge_pair in assembly.liaison_graph.items():
            instance_a = assembly.instances[inst_a]
            instance_b = assembly.instances[inst_b]
            
            edge_idx_a = edge_pair['edge_a']
            edge_idx_b = edge_pair['edge_b']
            
            # Get faces adjacent to these edges
            face_a = self.get_adjacent_face(instance_a, edge_idx_a)
            face_b = self.get_adjacent_face(instance_b, edge_idx_b)
            
            # Check coplanarity
            if self.are_coplanar(face_a, face_b):
                merged_faces.append({
                    'faces': [face_a, face_b],
                    'shared_edge': edge_pair,
                })
        
        return merged_faces
    
    async def warm_new_symbol(self, symbol, attachment_patterns):
        """
        Asynchronously warm cache for newly discovered polyform.
        """
        # Series A: all edges available (just closed, no faces merged yet)
        # (Face merge happens on GPU, Series A represents post-merge state)
        
        for edge_idx, compatible in attachment_patterns.items():
            cache_key = (symbol, 'A', edge_idx)
            self.attachment_cache[cache_key] = compatible
GPU Face Merge Execution
glsl// Babylon.js/WebGL

void execute_face_merge(MergeCommand cmd) {
    for each merge_op in cmd.merged_faces {
        face_a = cmd.assembly.instances[merge_op.inst_a].faces[merge_op.edge_a];
        face_b = cmd.assembly.instances[merge_op.inst_b].faces[merge_op.edge_b];
        
        // Verify coplanarity
        if (dot(face_a.normal, face_b.normal) > 0.99) {
            
            // Combine vertex lists
            merged_vertices = union(face_a.vertices, face_b.vertices);
            
            // Remove shared edge vertices
            shared_edge = compute_shared_edge(face_a, face_b);
            merged_vertices = remove_vertices_on(merged_vertices, shared_edge);
            
            // Recompute merged face (convex hull if needed)
            merged_face = construct_convex_polygon(merged_vertices);
            
            // Update GPU mesh
            update_mesh_face(cmd.assembly, merge_op, merged_face);
        }
    }
    
    emit_signal("face_merge_complete", cmd.result_symbol);
}
Deliverable after Phase 2 (4‚Äì5 hours)

‚úÖ Closure detection (0 boundary edges)
‚úÖ Face merge on GPU (coplanar face identification + merge)
‚úÖ Unicode symbol allocation (O(1))
‚úÖ New attachment patterns extracted + cached
‚úÖ Save to tier2_catalog.jsonl
‚úÖ New symbol immediately available as seed


PHASE 3: Generator System with Scalar Expansion (2‚Äì3 hours)
Seed-Based Generation
pythonclass GeneratorEngine:
    """
    Uses discovered polyforms (Tier 2/3) as seeds.
    Generates progressions: 1 seed ‚Üí 2 seeds ‚Üí 4 seeds (exponential).
    """
    
    def generate_from_seed(self, seed_unicode, growth_mode='linear'):
        """
        seed: e.g., "ùêÄ" (single discovered polyform)
        growth_mode: 'linear' (1‚Üí2‚Üí3) or 'exponential' (1‚Üí2‚Üí4‚Üí8)
        """
        # Step 1: Decompose seed into Tier 0 primitives
        decomposition = self.decompose_symbol(seed_unicode)
        
        # Step 2: Count primitives
        primitive_counts = {}
        for prim in decomposition:
            primitive_counts[prim] = primitive_counts.get(prim, 0) + 1
        
        dominant_prim = max(primitive_counts, key=primitive_counts.get)
        
        # Step 3: Generate progression
        for step in range(1, 8):  # Up to 8 generations
            if growth_mode == 'linear':
                target_count = primitive_counts[dominant_prim] * step
            else:  # exponential
                target_count = primitive_counts[dominant_prim] * (2 ** step)
            
            # Step 4: Enumerate topologies with this primitive count
            for topology in self.enumerate_topologies(dominant_prim, target_count):
                polyform = self.assemble_from_topology(topology)
                
                # Step 5: Check if closed
                if polyform.is_closed():
                    # Allocate symbol
                    new_symbol = allocator.allocate_symbol(
                        category='generated_polyform',
                        metadata={'parent_seed': seed_unicode, 'step': step}
                    )
                    
                    yield (new_symbol, polyform)
                    
                    # Step 6: Register as new seed
                    self.register_seed(new_symbol)
Scalar Expansion with Workspace Centering
pythondef on_scalar_expansion(self, assembly, scalar_factor):
    """
    User applies scalar to assembly.
    Expands in all directions while keeping centered.
    """
    # Step 1: Compute current bounding box
    bb_min, bb_max = assembly.compute_bounding_box()
    bb_center_z = (bb_max[2] + bb_min[2]) / 2
    
    # Step 2: Scale all vertices around their local origins
    for instance in assembly.instances.values():
        for vertex in instance['vertices']:
            vertex *= scalar_factor  # Scale relative to origin
    
    # Step 3: Recompute bounding box after scaling
    new_bb_min, new_bb_max = assembly.compute_bounding_box()
    new_height = new_bb_max[2] - new_bb_min[2]
    
    # Step 4: Move assembly up so it's centered in workspace
    workspace_center_z = 0  # Hardcoded, or configurable
    target_z = workspace_center_z - (new_height / 2)
    
    for instance in assembly.instances.values():
        instance['position'][2] = target_z
    
    # Step 5: GPU re-renders
    gpu_update = {
        'action': 'scalar_expansion',
        'scalar': scalar_factor,
        'new_center_z': workspace_center_z,
    }
    assembly.gpu_queue.put(gpu_update)
Deliverable after Phase 3 (2‚Äì3 hours)

‚úÖ Seed-based generator (linear + exponential modes)
‚úÖ Scalar expansion with workspace centering
‚úÖ LOD pre-computation for generated polyforms
‚úÖ Each generation registered as new seed
‚úÖ Closed polyforms saved to tier2_catalog
‚úÖ Full pipeline: Foundation ‚Üí Phase 1 (warm) ‚Üí Phase 2 (discover) ‚Üí Phase 3 (generate)


SUMMARY: Corrected Path (13‚Äì16 hours)
MilestoneDurationKey WinsFoundation4‚Äì5 hrsDrag-drop, 2D placement, edge snapping, free rotation, 2D‚Üí3D foldingPhase 13‚Äì4 hrsSeries A/B/C/D Unicode cache, async CPU warming, O(1) attachment lookupsPhase 24‚Äì5 hrsFace pruning, Unicode allocation, new attachment pattern extractionPhase 32‚Äì3 hrsSeed-based generator, scalar expansion, workspace centering