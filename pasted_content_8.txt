
**Date:** 2025-11-08  
**Status:** Post-guardrail integration, pre-catalog population

Purpose: Equip Agent 1 with actionable specifications, fixtures, and integration
points required to deliver full runtime engine functionality for the polyform
simulator.

---

## 1. Current Engine Status

### âœ… Completed Components

| Component | Module(s) | Status | Evidence |
|-----------|-----------|--------|----------|
| Guardrail Integration | `simulation/engines/guardrails.py` | âœ… Complete | Dimension-aware evaluation merged; regression suite green |
| Catalog Scaffolding | `scripts/generate_*.py`, `catalogs/` | âœ… Complete | All four generators emit representative data |
| Catalog Loading | `simulation/placement/runtime.py` | âœ… Ready | `CatalogBackedHydrator` instantiates with version validation |
| Storage Regression | `storage/tests/test_storage_pipeline.py` | âœ… Extended | Mega-scale fixtures (128â€“8192 polygons) parametrized |

### ðŸ”„ In Progress / Pending

| Component | Module(s) | Need | Blocker |
|-----------|-----------|------|---------|
| Placement Runtime | `simulation/placement/runtime.py` | Real attachment resolution | Catalog population incomplete |
| Combinatorial Calculator | `combinatorial/calculator.py` | Cascading O/I computation | Scaler tables need authoritative O values |
| Fold Sequencer | `fold_sequencer.py` | Pre-computed fold angles | Attachment enumeration incomplete |
| Collision Detection | `bvh3d.py` | Validation against populated catalogs | Geometry catalog requires dense coordinates |

---

## 2. Resource Gaps & Implementation Roadmaps

### Gap 1 â€” Placement Runtime Attachment Resolution

#### Current State (Placement)

- `CatalogBackedHydrator` loads `attachment_graph.json`, but placement runtime does
  not yet query or score attachments.

#### Required APIs (Placement)

```python
class AttachmentResolver:
    def find_attachments(self, assembly, new_polyform) -> list[dict]:
        """Return candidate attachments for the incoming polyform."""

    def score(self, attachment: dict, assembly) -> float:
        """Rank candidates by stability, closure fit, and collision results."""
```

- scoring heuristic: `stability_score Ã— closure_fit Ã— collision_gate`
- collision gate leverages BVH check (Gap 4).

#### Execution Hook (Placement)

```python
def apply_attachment(self, assembly, attachment):
    fold_angle = attachment["fold_angle_range"]["preferred"]
    return assembly.fold_edge(
        attachment["source_polygon_idx"],
        attachment["target_polygon_idx"],
        fold_angle,
    )
```

#### Test Fixture (`tests/test_placement_with_catalog.py`)

```python
@pytest.fixture
def catalog_backed_runtime(tmp_path):
    return PlacementRuntime(catalog_dir="./catalogs")

def test_placement_finds_valid_attachments(catalog_backed_runtime):
    attachments = catalog_backed_runtime.find_attachments("triangle", "square")
    assert attachments and all("stability_score" in att for att in attachments)

def test_placement_executes_fold(catalog_backed_runtime):
    assembly = create_test_assembly()
    new_poly = Polygon("square")
    attachment = catalog_backed_runtime.find_attachments("triangle", "square")[0]
    result = catalog_backed_runtime.apply_attachment(assembly, attachment)
    assert len(result.polygons) == 2
```

#### Roadmap (Placement)

1. Implement `placement/attachment_resolver.py` with query + scoring logic.  
2. Inject resolver into `PlacementRuntime.place_polyform()`.  
3. Add fixtures consuming `attachment_graph.json` triangleâ†”triangle and triangleâ†”square entries.

---

### Gap 2 â€” Combinatorial Calculator (O/I Metrics)

#### Current State (Combinatorial)

`combinatorial/calculator.py` is a stub; O and I values derived from scaler
tables are unavailable.

#### Required Class (Combinatorial)

```python
class CombinatorialCalculator:
    def __init__(self, scaler_tables: dict):
        self.scaler_tables = scaler_tables
        self.memo_O: dict[str, float] = {}
        self.memo_I: dict[str, float] = {}
        self._seed_known_polyhedra()

    def calculate_O(self, assembly, method: str = "auto") -> float:
        ...  # cascading â†’ enumeration â†’ estimation

    def calculate_I(self, assembly, O_value: float | None = None) -> float:
        ...  # I = O Ã— s_total Ã— Ac Ã— C_sym
```

- Utilize `functools.lru_cache` for signature creation.  
- Seed memo tables from cataloged polyhedra (Platonic, Archimedean, Johnson).  
- Provide cascading decomposition via BVH clustering.

#### Test Fixture (`tests/test_combinatorial_calculator.py`)

```python
@pytest.fixture
def calculator_with_scaler_tables():
    tables = load_json("catalogs/scaler_tables.json")
    return CombinatorialCalculator(tables)

def test_O_for_known_tetrahedron(calculator_with_scaler_tables):
    O = calculator_with_scaler_tables.calculate_O(Polyform.tetrahedron())
    assert O == 1.0

def test_I_formula_for_pentominoes(calculator_with_scaler_tables):
    pentomino = Polyform([Polygon("square") for _ in range(5)])
    I = calculator_with_scaler_tables.calculate_I(pentomino, O_value=18)
    assert abs(I - 368_640) < 1
```

#### Roadmap (Combinatorial)

1. Implement calculator logic with cascading + memoization.  
2. Populate scaler tables with authoritative O/I values.  
3. Wire calculator into `PlacementRuntime.update_metrics()`.

---

### Gap 3 â€” Fold Sequencer (Instantaneous Folding)

#### Current State (Fold Sequencer)

`fold_sequencer.py` contains only stubs; no geometry-aware folding or collision
validation exists.

#### Required Class (Fold Sequencer)

```python
class FoldSequencer:
    def __init__(self, geometry_catalog: dict, attachment_graph: dict):
        self.geometry_catalog = geometry_catalog
        self.attachment_graph = attachment_graph

    def execute_fold_sequence(self, assembly, attachment):
        fold_angle = attachment["fold_angle_range"]["preferred"]
        ...  # validate range, rotate vertices, collision check
        return folded_assembly, metadata
```

- Reuse geometry catalog vertices for rotations.  
- Integrate BVH collision detection from Gap 4.  
- Return metadata: `fold_angle_used`, `collision_free`, `stability_score`, `attachment_id`.

#### Test Fixture (`tests/test_fold_sequencer.py`)

```python
@pytest.fixture
def fold_sequencer_with_catalogs():
    geometry = load_json("catalogs/geometry_catalog.json")
    attachments = load_json("catalogs/attachment_graph.json")
    return FoldSequencer(geometry, attachments)

def test_fold_executes_instantly(fold_sequencer_with_catalogs):
    folded, meta = fold_sequencer_with_catalogs.execute_fold_sequence(...)
    assert meta["collision_free"] and len(folded.polygons) == 2
```

#### Roadmap (Fold Sequencer)

1. Flesh out FoldSequencer with vertex rotation helpers and angle guards.  
2. Integrate BVH collision checks.  
3. Surface metadata for placement metrics and logging.

---

### Gap 4 â€” Collision Detection Validation

- `bvh3d.py` requires calibration against populated geometry catalog coordinates.  
- Action: add unit tests that replay catalog polygons through BVH and ensure no
  false collisions for canonical assemblies.

---

## 3. Placement Runtime Integration Points

```python
class PlacementRuntime:
    def __init__(self, catalog_dir: str = "./catalogs"):
        self.catalog = CatalogBackedHydrator(catalog_dir)
        self.attachment_resolver = AttachmentResolver(self.catalog.attachment_graph)
        self.fold_sequencer = FoldSequencer(
            self.catalog.geometry_catalog,
            self.catalog.attachment_graph,
        )
        self.combinatorial_calc = CombinatorialCalculator(self.catalog.scaler_tables)
        self.collision_checker = BVH3DCollisionChecker()

    def place_polyform(self, assembly, new_polygon):
        attachments = self.attachment_resolver.find_attachments(assembly, new_polygon)
        if not attachments:
            raise PlacementError(f"No valid attachments for {new_polygon}")

        best = max(attachments, key=lambda a: self.attachment_resolver.score(a, assembly))
        folded, fold_meta = self.fold_sequencer.execute_fold_sequence(assembly, best)

        O = self.combinatorial_calc.calculate_O(folded)
        I = self.combinatorial_calc.calculate_I(folded, O)

        return PlacementResult(
            assembly=folded,
            O_value=O,
            I_value=I,
            attachment_used=best,
            fold_metadata=fold_meta,
        )
```

---

## 4. Testing Strategy

1. **Unit Tests**  
   - `tests/test_placement_with_catalog.py` â€“ Attachment resolver hooks.  
   - `tests/test_fold_sequencer.py` â€“ Angle validation & collision gating.  
   - `tests/test_combinatorial_calculator.py` â€“ O/I correctness.

2. **Integration Tests**  
   - `tests/test_placement_runtime_integration.py` â€“ End-to-end placement cycle.  

3. **Regression Tests**  
   - `storage/tests/test_storage_pipeline.py` â€“ Chunking parity.  
   - `simulation/tests/test_guardrails.py` â€“ Guardrail stability.  

4. **Performance Benchmarks**  
   - `tests/test_placement_performance.py` â€“ < 100 ms per placement target.

---

## 5. Validation Checklist

- [ ] Attachment resolver queries `attachment_graph.json` correctly.  
- [ ] Attachment scoring prioritizes stability + closure fit.  
- [ ] Fold sequencer executes folds instantly (< 10 ms).  
- [ ] Fold angles respect min/max constraints.  
- [ ] Collision detection prevents overlapping placements.  
- [ ] Combinatorial calculator matches pentomino ground truth (O = 18).  
- [ ] I formula reproduces tetrahedron expectations (â‰ˆ 7).  
- [ ] Cascading O decomposition reduces runtime for large assemblies.  
- [ ] Placement runtime integrates all engines end-to-end.  
- [ ] Metrics update after each placement.  
- [ ] All tests pass with no performance regressions.

---

## 6. Next Steps for Agent 1

**Priority Path A â€“ Main Integration**

1. Implement attachment resolver + placement runtime wiring.  
2. Build combinatorial calculator with cascading O/I.  
3. Implement fold sequencer and collision validation.  
4. Execute integration tests and confirm performance targets.

**Path B â€“ Easy Wins (Self-Isolated)**

1. Harden scaler tables with authoritative O/I values for additional polyhedra.  
2. Expand LOD metadata coverage (profiling harness).  
3. Document placement runtime SOP once integration stabilizes.

---

## 7. Resources Provided

- Catalog JSON structure: geometry, attachment, scaler, LOD.  
- Representative fixtures for attachment scoring and fold execution.  
- Formula specifications for O/I computation.  
- Integration blueprint for `PlacementRuntime.place_polyform()`.  
- Regression harness baseline (storage pipeline, guardrails).
