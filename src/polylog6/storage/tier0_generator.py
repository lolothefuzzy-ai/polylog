"""Tier 0 hierarchical symbol generator.

This module derives the complete Tier 0 vocabulary at runtime so every
installation builds the same Unicode index on first startup. The generator
covers single primitives, two-polygon connections, and three-polygon chains as
specified in the hierarchical Tier 0 encoding system (version 3.0).
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple

from .tier0_enrichment import Tier0Metadata, build_tier0_metadata
import json

# Series reference table (canonical edge counts – definitive spec)
SERIES_TABLE: Dict[str, List[int]] = {
    "A": [3, 4, 5, 6, 7, 8, 9, 10, 11],
    "B": [20, 4, 6, 8, 10, 12, 14, 16, 18],
    "C": [3, 6, 9, 12, 15, 18, 8, 7, 10],
    "D": [14, 20, 13, 11, 4, 16, 17, 5, 19],
}


def _build_edge_to_series_refs() -> Dict[int, List[Tuple[str, int]]]:
    """Invert ``SERIES_TABLE`` to expose redundancy paths."""

    mapping: Dict[int, List[Tuple[str, int]]] = {}
    for series, entries in SERIES_TABLE.items():
        for position, edge_count in enumerate(entries, start=1):
            mapping.setdefault(edge_count, []).append((series, position))
    return mapping


EDGE_TO_SERIES_REFS: Dict[int, List[Tuple[str, int]]] = _build_edge_to_series_refs()


def _get_secondary_series_for_base_and_hundreds(base_series: str, hundreds: int) -> str:
    """Route hundreds digit to the appropriate secondary series."""

    cyclic_map: Dict[str, List[str]] = {
        "A": ["C", "D", "B"],
        "B": ["D", "A", "C"],
        "C": ["A", "B", "D"],
        "D": ["B", "C", "A"],
    }

    if base_series not in cyclic_map:
        raise ValueError(f"Invalid base series: {base_series!r}")

    sequence = cyclic_map[base_series]

    if hundreds in (1, 2):
        return sequence[hundreds - 1]

    if hundreds in (3, 4, 5):
        return sequence[hundreds - 3]

    if hundreds in (6, 7, 8):
        return sequence[hundreds - 6]

    raise ValueError(f"Invalid hundreds digit for secondary selection: {hundreds}")


@dataclass(slots=True)
class ConnectivityChain:
    """Connectivity metadata for a Tier 0 symbol."""

    symbol: str
    polygons: List[int]
    positions: List[int]
    series: List[str]

    def __str__(self) -> str:  # pragma: no cover - helper for debugging
        parts = [f"{s}{p}({e})" for s, p, e in zip(self.series, self.positions, self.polygons)]
        return f"{self.symbol}: {' → '.join(parts)}"

    def to_dict(self, metadata: Optional[Tier0Metadata] = None) -> Dict[str, object]:
        """Serialize chain for export helpers.

        Parameters
        ----------
        metadata:
            Optional enrichment payload generated by ``build_tier0_metadata``.
            When provided, its dictionary representation is merged into the
            serialized output so downstream consumers receive the full metadata
            context.
        """

        payload: Dict[str, object] = {
            "symbol": self.symbol,
            "polygons": self.polygons,
            "positions": self.positions,
            "series": self.series,
            "chain_length": len(self.polygons),
            "edge_signature": "-".join(str(edge) for edge in self.polygons),
        }

        if metadata is not None:
            payload.update(metadata.to_dict())

        return payload


def _require_uppercase_series(symbol: str) -> None:
    if not symbol or len(symbol) < 2:
        raise ValueError(f"Invalid Tier 0 symbol: {symbol!r}")

    series = symbol[0]
    if series not in SERIES_TABLE:
        raise ValueError(f"Invalid series in Tier 0 symbol: {symbol!r}")

    if series != series.upper():
        raise ValueError(f"Tier 0 series must be uppercase: {symbol!r}")


def _decode_single_digit(series: str, position: int, symbol: str) -> ConnectivityChain:
    if position < 1 or position > 9:
        raise ValueError(f"Invalid position for single-digit Tier 0 symbol: {symbol!r}")

    edge_count = SERIES_TABLE[series][position - 1]
    return ConnectivityChain(symbol=symbol, polygons=[edge_count], positions=[position], series=[series])


def _decode_two_digit(series: str, tens: int, ones: int, symbol: str) -> ConnectivityChain:
    if ones == 0:
        raise ValueError(f"Invalid {symbol!r}: skip rule prohibits X0 patterns")

    if tens < 1 or tens > 9 or ones < 1 or ones > 9:
        raise ValueError(f"Invalid digits for Tier 0 two-digit symbol: {symbol!r}")

    base_edges = SERIES_TABLE[series][tens - 1]
    bridge_edges = SERIES_TABLE["B"][ones - 1]

    return ConnectivityChain(
        symbol=symbol,
        polygons=[base_edges, bridge_edges],
        positions=[tens, ones],
        series=[series, "B"],
    )


def _decode_three_digit(series: str, hundreds: int, tens: int, ones: int, symbol: str) -> ConnectivityChain:
    if hundreds == 9:
        raise ValueError(f"Reserved Tier 0 range: {symbol!r}")

    if tens == 0 or ones == 0:
        raise ValueError(f"Invalid {symbol!r}: skip rule prohibits X00, X0Y, and XY0 patterns")

    if hundreds < 1 or hundreds > 8 or tens < 1 or tens > 9 or ones < 1 or ones > 9:
        raise ValueError(f"Invalid digits for Tier 0 three-digit symbol: {symbol!r}")

    base_edges = SERIES_TABLE[series][tens - 1]

    secondary = _get_secondary_series_for_base_and_hundreds(series, hundreds)
    secondary_edges = SERIES_TABLE[secondary][ones - 1]

    if hundreds <= 2:
        return ConnectivityChain(
            symbol=symbol,
            polygons=[base_edges, secondary_edges],
            positions=[tens, ones],
            series=[series, secondary],
        )

    bridge_edges = SERIES_TABLE["B"][ones - 1]

    if hundreds <= 5:
        return ConnectivityChain(
            symbol=symbol,
            polygons=[base_edges, bridge_edges, secondary_edges],
            positions=[tens, ones, tens],
            series=[series, "B", secondary],
        )

    return ConnectivityChain(
        symbol=symbol,
        polygons=[base_edges, bridge_edges, secondary_edges],
        positions=[tens, ones, ones],
        series=[series, "B", secondary],
    )


def decode_tier0_symbol(symbol: str) -> ConnectivityChain:
    """Decode any Tier 0 symbol according to the definitive specification."""

    _require_uppercase_series(symbol)

    series = symbol[0]
    digits = symbol[1:]

    if not digits.isdigit():
        raise ValueError(f"Tier 0 subscript must be numeric: {symbol!r}")

    if len(symbol) == 2:
        position = int(digits)
        return _decode_single_digit(series, position, symbol)

    if len(symbol) == 3:
        tens = int(digits[0])
        ones = int(digits[1])
        return _decode_two_digit(series, tens, ones, symbol)

    if len(symbol) == 4:
        hundreds = int(digits[0])
        tens = int(digits[1])
        ones = int(digits[2])
        return _decode_three_digit(series, hundreds, tens, ones, symbol)

    raise ValueError(f"Unsupported Tier 0 symbol length: {symbol!r}")
class Tier0Generator:
    """Generate the complete Tier 0 hierarchical vocabulary."""

    def __init__(self) -> None:
        self.series_table = SERIES_TABLE
        self.generated_symbols: Dict[str, ConnectivityChain] = {}
        self.by_edges: Dict[int, List[str]] = {}
        self.by_chain_length: Dict[int, List[str]] = {1: [], 2: [], 3: []}
        self.by_series_pair: Dict[Tuple[str, str], List[str]] = {}
        self.by_third_series: Dict[str, List[str]] = {"A": [], "B": [], "C": [], "D": []}

    def generate_all(self) -> Dict[str, ConnectivityChain]:
        """Generate every Tier 0 symbol (idempotent)."""

        if self.generated_symbols:
            return self.generated_symbols

        for base_char in ("A", "B", "C", "D"):
            self._generate_single_digit(base_char)
            self._generate_two_digit(base_char)
            self._generate_three_digit(base_char)

        return self.generated_symbols

    # ------------------------------------------------------------------
    # Generation helpers
    # ------------------------------------------------------------------
    def _generate_single_digit(self, base_char: str) -> None:
        for position in range(1, 10):
            symbol = f"{base_char}{position}"
            chain = self._decode_single_digit(base_char, position)
            self._register_symbol(symbol, chain)

    def _generate_two_digit(self, base_char: str) -> None:
        for tens in range(1, 10):
            for ones in range(1, 10):
                symbol = f"{base_char}{tens}{ones}"
                chain = self._decode_two_digit(base_char, tens, ones)
                self._register_symbol(symbol, chain)

    def _generate_three_digit(self, base_char: str) -> None:
        for hundreds in range(1, 10):  # include 900-999 range
            for tens in range(1, 10):
                for ones in range(1, 10):
                    symbol = f"{base_char}{hundreds}{tens}{ones}"
                    chain = self._decode_three_digit(base_char, hundreds, tens, ones)
                    self._register_symbol(symbol, chain)

    # ------------------------------------------------------------------
    # Decoding helpers
    # ------------------------------------------------------------------
    def _decode_single_digit(self, base_char: str, position: int) -> ConnectivityChain:
        edges = self.series_table[base_char][position - 1]
        return ConnectivityChain(
            symbol=f"{base_char}{position}",
            polygons=[edges],
            positions=[position],
            series=[base_char],
        )

    def _decode_two_digit(self, base_char: str, tens: int, ones: int) -> ConnectivityChain:
        base_edges = self.series_table[base_char][tens - 1]
        bridge_edges = self.series_table["B"][ones - 1]
        return ConnectivityChain(
            symbol=f"{base_char}{tens}{ones}",
            polygons=[base_edges, bridge_edges],
            positions=[tens, ones],
            series=[base_char, "B"],
        )

    def _decode_three_digit(
        self, base_char: str, hundreds: int, tens: int, ones: int
    ) -> ConnectivityChain:
        """Decode three-digit subscript (100-999) into connectivity chain."""

        symbol = f"{base_char}{hundreds}{tens}{ones}"
        base_edges = self.series_table[base_char][tens - 1]

        if hundreds == 1:
            # 100-199: Base + C (ones index)
            c_edges = self.series_table["C"][ones - 1]
            return ConnectivityChain(
                symbol=symbol,
                polygons=[base_edges, c_edges],
                positions=[tens, ones],
                series=[base_char, "C"],
            )

        if hundreds == 2:
            # 200-299: Base + D (ones index)
            d_edges = self.series_table["D"][ones - 1]
            return ConnectivityChain(
                symbol=symbol,
                polygons=[base_edges, d_edges],
                positions=[tens, ones],
                series=[base_char, "D"],
            )

        b_edges = self.series_table["B"][ones - 1]

        if hundreds in (3, 4):
            # 300-499: third polygon uses tens reference (C or D)
            third_series_map = {3: "C", 4: "D"}
            third_series = third_series_map[hundreds]
            third_edges = self.series_table[third_series][tens - 1]
            return ConnectivityChain(
                symbol=symbol,
                polygons=[base_edges, b_edges, third_edges],
                positions=[tens, ones, tens],
                series=[base_char, "B", third_series],
            )

        if hundreds in (5, 6):
            # 500-699: third polygon uses ones reference (C or D)
            third_series_map = {5: "C", 6: "D"}
            third_series = third_series_map[hundreds]
            third_edges = self.series_table[third_series][ones - 1]
            return ConnectivityChain(
                symbol=symbol,
                polygons=[base_edges, b_edges, third_edges],
                positions=[tens, ones, ones],
                series=[base_char, "B", third_series],
            )

        if hundreds == 7:
            # 700-799: ABA pattern (third polygon mirrors base tens index)
            a_edges = self.series_table["A"][tens - 1]
            return ConnectivityChain(
                symbol=symbol,
                polygons=[base_edges, b_edges, a_edges],
                positions=[tens, ones, tens],
                series=[base_char, "B", "A"],
            )

        if hundreds == 8:
            # 800-899: ACA pattern (third polygon uses ones index)
            c_edges = self.series_table["C"][ones - 1]
            a_edges = self.series_table["A"][ones - 1]
            return ConnectivityChain(
                symbol=symbol,
                polygons=[base_edges, c_edges, a_edges],
                positions=[tens, ones, ones],
                series=[base_char, "C", "A"],
            )

        if hundreds == 9:
            # 900-999: ACD pattern (third polygon uses tens index)
            c_edges = self.series_table["C"][ones - 1]
            d_edges = self.series_table["D"][tens - 1]
            return ConnectivityChain(
                symbol=symbol,
                polygons=[base_edges, c_edges, d_edges],
                positions=[tens, ones, tens],
                series=[base_char, "C", "D"],
            )

        raise ValueError(f"Invalid hundreds digit: {hundreds}")

    # ------------------------------------------------------------------
    # Index helpers
    # ------------------------------------------------------------------
    def _register_symbol(self, symbol: str, chain: ConnectivityChain) -> None:
        key = symbol.lower()
        self.generated_symbols[key] = chain

        length = len(chain.polygons)
        self.by_chain_length[length].append(key)

        for edges in chain.polygons:
            self.by_edges.setdefault(edges, []).append(key)

        if length >= 2:
            pair = (chain.series[0], chain.series[1])
            self.by_series_pair.setdefault(pair, []).append(key)

        if length == 3:
            third_series = chain.series[2]
            self.by_third_series.setdefault(third_series, []).append(key)

    # ------------------------------------------------------------------
    # Query helpers
    # ------------------------------------------------------------------
    def get_chain(self, symbol: str) -> Optional[ConnectivityChain]:
        return self.generated_symbols.get(symbol.lower())

    def get_by_edges(self, edge_count: int) -> List[str]:
        return list(self.by_edges.get(edge_count, ()))

    def get_by_chain_length(self, length: int) -> List[str]:
        return list(self.by_chain_length.get(length, ()))

    def get_by_series_pair(self, base_series: str, second_series: str) -> List[str]:
        key = (base_series.upper(), second_series.upper())
        return list(self.by_series_pair.get(key, ()))

    def get_by_pattern(
        self,
        base_edges: int,
        second_edges: Optional[int] = None,
        third_edges: Optional[int] = None,
    ) -> List[str]:
        if second_edges is None:
            return [
                symbol
                for symbol in self.by_chain_length[1]
                if self.generated_symbols[symbol].polygons[0] == base_edges
            ]

        target_length = 3 if third_edges is not None else 2
        matches: List[str] = []
        for symbol in self.by_chain_length[target_length]:
            chain = self.generated_symbols[symbol]
            if target_length == 2:
                if chain.polygons[0] == base_edges and chain.polygons[1] == second_edges:
                    matches.append(symbol)
            else:
                if chain.polygons == [base_edges, second_edges, third_edges]:
                    matches.append(symbol)
        return matches

    def get_three_polygon_chains(self) -> List[str]:
        return list(self.by_chain_length[3])

    def get_by_third_series(self, series: str) -> List[str]:
        """Return all three-polygon chains whose third polygon belongs to the given series."""

        return list(self.by_third_series.get(series.upper(), ()))

    # ------------------------------------------------------------------
    # Export helpers
    # ------------------------------------------------------------------
    def export_to_dict(self) -> Dict[str, object]:
        catalog = self.generate_all()
        return {
            "version": "1.0",
            "encoding_type": "hierarchical_tier0",
            "total_symbols": len(catalog),
            "symbols": [chain.to_dict() for chain in catalog.values()],
        }

    def export_to_json(self, filepath: str) -> None:
        with open(filepath, "w", encoding="utf-8") as stream:
            json.dump(self.export_to_dict(), stream, indent=2)

    def export_to_jsonl(self, filepath: str) -> None:
        catalog = self.generate_all()
        with open(filepath, "w", encoding="utf-8") as stream:
            for symbol in sorted(catalog):
                chain = catalog[symbol]
                metadata = build_tier0_metadata(chain.symbol)
                stream.write(json.dumps(chain.to_dict(metadata)))
                stream.write("\n")


def generate_tier0_catalog() -> Dict[str, ConnectivityChain]:
    """Return a freshly generated Tier 0 catalog."""

    generator = Tier0Generator()
    return generator.generate_all()


__all__ = [
    "ConnectivityChain",
    "Tier0Generator",
    "SERIES_TABLE",
    "generate_tier0_catalog",
]
