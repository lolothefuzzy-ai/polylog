"""Tier 0 hierarchical symbol generator.

This module derives the complete Tier 0 vocabulary at runtime so every
installation builds the same Unicode index on first startup. The generator
covers single primitives, two-polygon connections, and three-polygon chains as
specified in the hierarchical Tier 0 encoding system (version 3.0).
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple

from .tier0_enrichment import Tier0Metadata, build_tier0_metadata
import json

# Series reference table (canonical edge counts)
# Updated with C₇↔C₈ swap and D reordering to eliminate position conflicts
SERIES_TABLE: Dict[str, List[int]] = {
    "A": [11, 13, 3, 15, 5, 17, 7, 19, 9],     # Odds/primes
    "B": [20, 4, 6, 8, 10, 12, 14, 16, 18],    # Evens
    "C": [3, 6, 9, 12, 15, 18, 8, 7, 10],      # Multiples of 3 (C₇↔C₈ swapped)
    "D": [14, 20, 13, 11, 4, 16, 17, 5, 19],   # Complementary (reordered)
}


@dataclass(slots=True)
class ConnectivityChain:
    """Connectivity metadata for a Tier 0 symbol."""

    symbol: str
    polygons: List[int]
    positions: List[int]
    series: List[str]

    def __str__(self) -> str:  # pragma: no cover - helper for debugging
        parts = [f"{s}{p}({e})" for s, p, e in zip(self.series, self.positions, self.polygons)]
        return f"{self.symbol}: {' → '.join(parts)}"

    def to_dict(self, metadata: Optional[Tier0Metadata] = None) -> Dict[str, object]:
        """Serialize chain for export helpers.

        Parameters
        ----------
        metadata:
            Optional enrichment payload generated by ``build_tier0_metadata``.
            When provided, its dictionary representation is merged into the
            serialized output so downstream consumers receive the full metadata
            context.
        """

        payload: Dict[str, object] = {
            "symbol": self.symbol,
            "polygons": self.polygons,
            "positions": self.positions,
            "series": self.series,
            "chain_length": len(self.polygons),
            "edge_signature": "-".join(str(edge) for edge in self.polygons),
        }

        if metadata is not None:
            payload.update(metadata.to_dict())

        return payload


class Tier0Generator:
    """Generate the complete Tier 0 hierarchical vocabulary."""

    def __init__(self) -> None:
        self.series_table = SERIES_TABLE
        self.generated_symbols: Dict[str, ConnectivityChain] = {}
        self.by_edges: Dict[int, List[str]] = {}
        self.by_chain_length: Dict[int, List[str]] = {1: [], 2: [], 3: []}
        self.by_series_pair: Dict[Tuple[str, str], List[str]] = {}
        self.by_third_series: Dict[str, List[str]] = {"A": [], "B": [], "C": [], "D": []}

    def generate_all(self) -> Dict[str, ConnectivityChain]:
        """Generate every Tier 0 symbol (idempotent)."""

        if self.generated_symbols:
            return self.generated_symbols

        for base_char in ("A", "B", "C", "D"):
            self._generate_single_digit(base_char)
            self._generate_two_digit(base_char)
            self._generate_three_digit(base_char)

        return self.generated_symbols

    # ------------------------------------------------------------------
    # Generation helpers
    # ------------------------------------------------------------------
    def _generate_single_digit(self, base_char: str) -> None:
        for position in range(1, 10):
            symbol = f"{base_char}{position}"
            chain = self._decode_single_digit(base_char, position)
            self._register_symbol(symbol, chain)

    def _generate_two_digit(self, base_char: str) -> None:
        for tens in range(1, 10):
            for ones in range(1, 10):
                symbol = f"{base_char}{tens}{ones}"
                chain = self._decode_two_digit(base_char, tens, ones)
                self._register_symbol(symbol, chain)

    def _generate_three_digit(self, base_char: str) -> None:
        for hundreds in range(1, 10):  # include 900-999 range
            for tens in range(1, 10):
                for ones in range(1, 10):
                    symbol = f"{base_char}{hundreds}{tens}{ones}"
                    chain = self._decode_three_digit(base_char, hundreds, tens, ones)
                    self._register_symbol(symbol, chain)

    # ------------------------------------------------------------------
    # Decoding helpers
    # ------------------------------------------------------------------
    def _decode_single_digit(self, base_char: str, position: int) -> ConnectivityChain:
        edges = self.series_table[base_char][position - 1]
        return ConnectivityChain(
            symbol=f"{base_char}{position}",
            polygons=[edges],
            positions=[position],
            series=[base_char],
        )

    def _decode_two_digit(self, base_char: str, tens: int, ones: int) -> ConnectivityChain:
        base_edges = self.series_table[base_char][tens - 1]
        bridge_edges = self.series_table["B"][ones - 1]
        return ConnectivityChain(
            symbol=f"{base_char}{tens}{ones}",
            polygons=[base_edges, bridge_edges],
            positions=[tens, ones],
            series=[base_char, "B"],
        )

    def _decode_three_digit(
        self, base_char: str, hundreds: int, tens: int, ones: int
    ) -> ConnectivityChain:
        """Decode three-digit subscript (100-999) into connectivity chain."""

        symbol = f"{base_char}{hundreds}{tens}{ones}"
        base_edges = self.series_table[base_char][tens - 1]

        if hundreds == 1:
            # 100-199: Base + C (ones index)
            c_edges = self.series_table["C"][ones - 1]
            return ConnectivityChain(
                symbol=symbol,
                polygons=[base_edges, c_edges],
                positions=[tens, ones],
                series=[base_char, "C"],
            )

        if hundreds == 2:
            # 200-299: Base + D (ones index)
            d_edges = self.series_table["D"][ones - 1]
            return ConnectivityChain(
                symbol=symbol,
                polygons=[base_edges, d_edges],
                positions=[tens, ones],
                series=[base_char, "D"],
            )

        b_edges = self.series_table["B"][ones - 1]

        if hundreds in (3, 4):
            # 300-499: third polygon uses tens reference (C or D)
            third_series_map = {3: "C", 4: "D"}
            third_series = third_series_map[hundreds]
            third_edges = self.series_table[third_series][tens - 1]
            return ConnectivityChain(
                symbol=symbol,
                polygons=[base_edges, b_edges, third_edges],
                positions=[tens, ones, tens],
                series=[base_char, "B", third_series],
            )

        if hundreds in (5, 6):
            # 500-699: third polygon uses ones reference (C or D)
            third_series_map = {5: "C", 6: "D"}
            third_series = third_series_map[hundreds]
            third_edges = self.series_table[third_series][ones - 1]
            return ConnectivityChain(
                symbol=symbol,
                polygons=[base_edges, b_edges, third_edges],
                positions=[tens, ones, ones],
                series=[base_char, "B", third_series],
            )

        if hundreds == 7:
            # 700-799: ABA pattern (third polygon mirrors base tens index)
            a_edges = self.series_table["A"][tens - 1]
            return ConnectivityChain(
                symbol=symbol,
                polygons=[base_edges, b_edges, a_edges],
                positions=[tens, ones, tens],
                series=[base_char, "B", "A"],
            )

        if hundreds == 8:
            # 800-899: ACA pattern (third polygon uses ones index)
            c_edges = self.series_table["C"][ones - 1]
            a_edges = self.series_table["A"][ones - 1]
            return ConnectivityChain(
                symbol=symbol,
                polygons=[base_edges, c_edges, a_edges],
                positions=[tens, ones, ones],
                series=[base_char, "C", "A"],
            )

        if hundreds == 9:
            # 900-999: ACD pattern (third polygon uses tens index)
            c_edges = self.series_table["C"][ones - 1]
            d_edges = self.series_table["D"][tens - 1]
            return ConnectivityChain(
                symbol=symbol,
                polygons=[base_edges, c_edges, d_edges],
                positions=[tens, ones, tens],
                series=[base_char, "C", "D"],
            )

        raise ValueError(f"Invalid hundreds digit: {hundreds}")

    # ------------------------------------------------------------------
    # Index helpers
    # ------------------------------------------------------------------
    def _register_symbol(self, symbol: str, chain: ConnectivityChain) -> None:
        key = symbol.lower()
        self.generated_symbols[key] = chain

        length = len(chain.polygons)
        self.by_chain_length[length].append(key)

        for edges in chain.polygons:
            self.by_edges.setdefault(edges, []).append(key)

        if length >= 2:
            pair = (chain.series[0], chain.series[1])
            self.by_series_pair.setdefault(pair, []).append(key)

        if length == 3:
            third_series = chain.series[2]
            self.by_third_series.setdefault(third_series, []).append(key)

    # ------------------------------------------------------------------
    # Query helpers
    # ------------------------------------------------------------------
    def get_chain(self, symbol: str) -> Optional[ConnectivityChain]:
        return self.generated_symbols.get(symbol.lower())

    def get_by_edges(self, edge_count: int) -> List[str]:
        return list(self.by_edges.get(edge_count, ()))

    def get_by_chain_length(self, length: int) -> List[str]:
        return list(self.by_chain_length.get(length, ()))

    def get_by_series_pair(self, base_series: str, second_series: str) -> List[str]:
        key = (base_series.upper(), second_series.upper())
        return list(self.by_series_pair.get(key, ()))

    def get_by_pattern(
        self,
        base_edges: int,
        second_edges: Optional[int] = None,
        third_edges: Optional[int] = None,
    ) -> List[str]:
        if second_edges is None:
            return [
                symbol
                for symbol in self.by_chain_length[1]
                if self.generated_symbols[symbol].polygons[0] == base_edges
            ]

        target_length = 3 if third_edges is not None else 2
        matches: List[str] = []
        for symbol in self.by_chain_length[target_length]:
            chain = self.generated_symbols[symbol]
            if target_length == 2:
                if chain.polygons[0] == base_edges and chain.polygons[1] == second_edges:
                    matches.append(symbol)
            else:
                if chain.polygons == [base_edges, second_edges, third_edges]:
                    matches.append(symbol)
        return matches

    def get_three_polygon_chains(self) -> List[str]:
        return list(self.by_chain_length[3])

    def get_by_third_series(self, series: str) -> List[str]:
        """Return all three-polygon chains whose third polygon belongs to the given series."""

        return list(self.by_third_series.get(series.upper(), ()))

    # ------------------------------------------------------------------
    # Export helpers
    # ------------------------------------------------------------------
    def export_to_dict(self) -> Dict[str, object]:
        catalog = self.generate_all()
        return {
            "version": "1.0",
            "encoding_type": "hierarchical_tier0",
            "total_symbols": len(catalog),
            "symbols": [chain.to_dict() for chain in catalog.values()],
        }

    def export_to_json(self, filepath: str) -> None:
        with open(filepath, "w", encoding="utf-8") as stream:
            json.dump(self.export_to_dict(), stream, indent=2)

    def export_to_jsonl(self, filepath: str) -> None:
        catalog = self.generate_all()
        with open(filepath, "w", encoding="utf-8") as stream:
            for symbol in sorted(catalog):
                chain = catalog[symbol]
                metadata = build_tier0_metadata(chain.symbol)
                stream.write(json.dumps(chain.to_dict(metadata)))
                stream.write("\n")


def generate_tier0_catalog() -> Dict[str, ConnectivityChain]:
    """Return a freshly generated Tier 0 catalog."""

    generator = Tier0Generator()
    return generator.generate_all()


__all__ = [
    "ConnectivityChain",
    "Tier0Generator",
    "SERIES_TABLE",
    "generate_tier0_catalog",
]
