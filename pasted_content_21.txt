# Optimal Polygon Representation Architectures for Computational Geometry

**Modern computational geometry systems universally favor array-based vertex representations with lazy-evaluated angle properties, leveraging symmetry group structures for compression and GPU-optimized memory layouts for real-time generation.** This synthesis of current research reveals that production systems (Three.js, CGAL, Unity, Unreal) abandoned parametric and linked-list representations in favor of explicit vertex sequences with on-demand property computation, achieving 5-10x performance improvements on modern hardware through cache locality while enabling GPU-parallel generation of millions of vertices per frame.

The architectural consensus emerged from hardware realities: GPUs process triangles not parameters, modern CPUs penalize pointer-chasing with 100-300 cycle RAM latencies versus 1-4 cycle cache hits, and symmetry group theory enables O(log n) compression of regular n-gons that previously required O(n) storage. Production implementations now store dihedral symmetry group descriptors (D_n) requiring merely log₂(n) bits to encode complete angular information, generating full geometry procedurally when needed rather than maintaining redundant coordinate and angle storage.

## Array-based representations dominate modern polygon storage architectures

The computational geometry research community resolved the circular linked list versus array debate decisively in favor of **contiguous memory layouts**. CGAL's Polygon_2 class defaults to std::vector storage, Three.js uses Float32BufferAttribute arrays for direct GPU upload, and Unity/Unreal employ uniform vertex buffer representations across all geometry types. Empirical benchmarks demonstrate that **array-based sequential access delivers 5-10x faster iteration** than linked lists due to hardware prefetching and cache line utilization, with modern CPUs loading 64-byte cache lines that capture multiple adjacent array elements per memory fetch.

The half-edge data structure (DCEL - Doubly-Connected Edge List) emerged as the theoretical foundation for production mesh systems, **trading modest 20% memory overhead for elimination of conditional branching**. Unlike the earlier winged-edge structure which stores 8 references per edge but requires orientation checks at every traversal, half-edges split each geometric edge into twin oriented half-edges storing 5-6 pointers each. This architectural choice proves critical on modern CPUs with deep pipelines where branch misprediction penalties outweigh the memory cost. CGAL implements this through two container strategies: HalfedgeDS_list for dynamic topology modification and HalfedgeDS_vector for traversal-heavy static meshes, with the vector variant providing superior cache performance once construction completes.

For regular polygon edge sequences specifically, research recommends **array-based storage with modulo arithmetic for circular traversal**. The implementation pattern stores vertices in a contiguous std::vector, with edge(i) accessing vertices[i] to vertices[(i+1) % n]. This approach achieves O(1) random edge access, excellent iteration performance through sequential memory layout, and minimal overhead—just the modulo operation for wraparound. Circular linked lists, while conceptually elegant for cyclic topology, suffer catastrophic performance degradation from pointer-chasing patterns that thrash CPU caches. The only scenarios justifying linked representations occur when meshes undergo frequent topological surgery (edge flips, vertex insertion/removal), where O(1) local modification outweighs O(n) iteration costs.

CGAL's circulator abstraction provides clean iteration syntax for cyclic sequences without exposing implementation details. The pattern uses do-while loops comparing current position to starting position, enabling type-safe circular traversal that integrates with algorithms expecting iterator interfaces. OpenMesh follows similar principles with block-allocated memory pools that improve linked-list locality by grouping nodes in contiguous chunks, though still inferior to pure arrays for sequential access. The architectural lesson: **separate combinatorial topology from memory layout**, allowing compile-time selection via template parameters while maintaining consistent high-level APIs.

## Interior and dihedral angle encoding exploits mathematical structure

Regular polygon interior angles follow the closed-form formula **(n-2)×180°/n**, converging toward the 180° limit as n approaches infinity. This simple relationship enables **lookup table encoding requiring merely 72 bytes** for all regular polygons from triangles (60°) through 20-gons, or direct O(1) computation from a single integer parameter. Production systems universally avoid storing angle values, instead **deriving angles procedurally** from the n parameter: Three.js CircleGeometry computes vertex positions as (radius×cos(2πi/n), radius×sin(2πi/n)) during construction then discards the parametric description.

Dihedral angles between faces in 3D polyhedra admit exact analytical solutions. Greg Egan's derivation for regular polyhedra where n faces meet at each vertex with regular f-gons yields: **sin(δ) = cos(π/n) / sin(π/f)**, where 2δ represents the dihedral angle. The five Platonic solids have precise values: tetrahedron arccos(1/3) ≈ 70.529°, cube exactly 90°, octahedron arccos(-1/3) ≈ 109.471°, dodecahedron arccos(-√5/5) ≈ 116.565°, icosahedron arccos(-√5/3) ≈ 138.190°. These angles prove essential for geodesic dome construction, where frequency-based subdivision creates multiple strut types requiring **pre-computed angle tables per frequency class** to enable physical assembly with correct hub angles.

Computational origami research established fundamental constraints relating angles to foldability. **Kawasaki's theorem** requires alternate angles around a flat-foldable vertex to sum to 180°, while **Maekawa's theorem** constrains the difference between mountain and valley creases to ±2. Polyhedral vertex validity demands that face angles meeting at a vertex sum to less than 360° in Euclidean space—equality produces planar configurations while exceeding 360° proves geometrically impossible. Descartes' theorem relates angular defect (360° minus sum of face angles) to Euler characteristic: total angular defect for closed polyhedra equals exactly 720° (4π steradians). These constraints directly link interior angle specifications to valid 3D folding configurations, making angle encoding central to origami simulation and polyhedral unfolding algorithms.

Modern angle encoding strategies emphasize **representation selection based on precision requirements**. Fixed-point binary angle formats (256 units per full circle) provide fast bitwise operations for embedded systems and game engines like Allegro. IEEE 754 floating-point offers 7 decimal digits (single precision) or 15 digits (double precision) suitable for most applications. Rational representations storing angles as multiples of π (e.g., π/3, 2π/5) enable exact geometric computation without floating-point accumulation errors, critical for symbolic geometry systems and verification algorithms. Quaternion and axis-angle representations avoid gimbal lock in 3D rotation applications, with quaternions requiring only 4 values versus 9 for full rotation matrices while enabling efficient composition and spherical interpolation.

## Symmetry group representations enable radical compression

The dihedral group **D_n contains 2n elements**—n rotational symmetries (multiples of 360°/n) plus n reflection symmetries through axes bisecting the polygon. This group structure **encodes complete angular information in O(log n) bits** versus O(n) for explicit vertex storage. The mathematical presentation D_n = ⟨r, s | r^n = s^2 = e, srs = r^(-1)⟩ captures rotational element r and reflection element s with their compositional rules. Since each interior angle equals 180° - 360°/n, the symmetry group order directly determines all angular properties—storing merely the integer n suffices to reconstruct full geometry.

**Orbifold notation** provides maximally compact symbolic encoding for 2D symmetry groups. Conway's system uses characters before asterisks for n-fold rotation points, asterisks to indicate reflection, and post-asterisk numbers for kaleidoscopic (2n-fold) points. Regular n-gons with full symmetry encode as *n• (e.g., *6• for hexagons), while rotation-only cyclic groups appear as n• (e.g., 5• for 5-fold rotation without reflection). The notation satisfies Conway's "Magic Theorem"—feature values sum to 2 for wallpaper groups, with the Euler characteristic χ = 2 - Σ(feature values) determining group order as 2/χ when finite. A single orbifold string captures complete symmetry structure in 2-6 characters, far more compact than listing group elements or vertex coordinates.

Computational exploitation of symmetry reduces storage requirements through **fundamental domain representations**. Only 1/(2n) of polygon vertices need explicit storage for D_n symmetry, with the remaining vertices generated by applying group operations. This pattern extends to mesh processing: the 2009 Princeton framework by Golovinskiy et al. demonstrated symmetry-aware remeshing that **separates symmetric base structures from asymmetric residuals**, enabling adaptive precision and massive compression for nearly-regular shapes. Fourier descriptor encoding produces sparse spectra for regular n-gons with peaks at multiples of n, requiring storage of only O(n/φ(n)) significant coefficients where φ denotes Euler's totient function.

Crystallographic notation systems provide alternative compact representations. Schoenflies notation denotes dihedral groups as D_n with subscripts indicating order (D₃, D₄, D₆), widely used in spectroscopy and molecular symmetry. Hermann-Mauguin international notation shows symmetry elements along crystallographic axes (2mm, 3m, 4mm, 6mm), with the crystallographic restriction limiting periodic lattices to 2-, 3-, 4-, and 6-fold rotations among 32 point groups total. This enumeration enables exhaustive classification schemes where group identifiers map directly to symmetry operation matrices.

Unicode mathematical symbols offer human-readable compact encoding: the Geometric Shapes block (U+25A0-U+25FF) provides △ (U+25B3 white triangle), ⬢ (U+2B22 black hexagon), and other primitives, while Mathematical Operators (U+2200-U+22FF) supply ∠ (U+2220 angle), ∟ (U+221F right angle), and related notation. Hybrid schemes combine these glyphs with subscripts for parametric specification: △₅ denotes a pentagon, D₆ indicates hexagonal dihedral symmetry. Orbifold strings mixed with Unicode achieve 2-8 byte specifications versus hundreds of bytes for coordinate arrays, though production systems prioritize binary efficiency over textual compactness.

## GPU-friendly architectures demand structure-of-arrays layouts

Modern GPU memory architectures achieve peak performance through **coalesced 128-byte memory transactions** when adjacent threads access adjacent memory locations. The Structure of Arrays (SoA) layout separates attributes into contiguous arrays—all positions [x₀y₀z₀, x₁y₁z₁, ...], all normals, all texture coordinates—enabling efficient bandwidth utilization when compute kernels process specific attributes. Empirical GPU benchmarks show **SoA delivers 1.25-1.72x speedup** over Array of Structures (AoS) layouts where vertex data interleaves [position, normal, texcoord] repeatedly. The AoS pattern wastes bandwidth when threads access only positions, fetching irrelevant normal and texcoord data that occupies cache lines.

Vertex buffer object (VBO) organization for GPU rendering follows **single large buffer patterns** with indexed triangle lists. Modern practice consolidates multiple meshes into unified VBOs using base-vertex rendering (glDrawElementsBaseVertex) for offset specification, dramatically reducing draw call overhead. Attribute compression exploits normalized integer formats—storing normals and tangents as 16-bit shorts achieves 50% footprint reduction with minimal quality loss. Critical optimization: **16-byte minimum alignment** for vertex data with 64-128 byte alignment for optimal cache line utilization, implemented via compiler attributes like `__attribute__((aligned(16)))` or manual padding in structure definitions.

**Hardware instancing** enables rendering millions of repeated geometric primitives with single draw calls. GPU-side access to gl_InstanceID or SV_InstanceID provides unique indices for per-instance data lookup from either vertex buffers, uniform buffer objects, or texture samplers. Production engines demonstrate 10-100x performance multipliers versus individual draw calls when rendering forests, particle systems, or architectural element arrays. Three implementation strategies dominate: vertex buffer instancing stores mat4 transforms as per-instance attributes consuming 4 attribute slots; uniform buffer instancing indexes fixed-size arrays (typical limit: 64-256 instances); texture-based instancing scales to millions of instances by sampling transform data from large texture arrays.

Compute shader procedural generation has supplanted traditional vertex shader approaches for complex parametric geometry. The pattern: **compute shader writes directly to vertex buffers** via storage buffer objects (SSBOs), then rendering pipelines consume these buffers with zero CPU synchronization. Benchmark data shows **13x faster training time and 69x faster generation** versus CPU approaches for machine learning-generated geometry. Edge sequence to vertex expansion maps naturally: each workgroup processes one parametric edge descriptor (Bezier control points, tessellation level, attributes), with threads evaluating the curve at parameter t = threadID / (workgroupSize - 1), writing results directly to output vertex positions at indices edgeID × workgroupSize + threadID.

**Mesh shaders represent the cutting edge**, replacing the traditional vertex→tessellation→geometry pipeline with task→mesh→rasterization. Mesh shaders directly generate arbitrary topology with maximum recommended limits of 64 vertices and 126 primitives per workgroup (NVIDIA) or 256 vertices/512 primitives (Metal). This architecture eliminates intermediate stream-out overhead of geometry shaders while maximizing on-chip data reuse within workgroups. Real-time procedural resurfacing research (Computer Graphics Forum 2024) demonstrates mesh shaders for parametric surface generation with task-shader-driven LOD selection and culling, bypassing tessellation entirely for low subdivision levels and achieving comparable or superior performance to optimized traditional pipelines.

Vulkan, DirectX 12, Metal, and WebGPU all converge on explicit memory management patterns requiring developer-specified resource states, transition barriers, and allocation strategies. Integer indices replace pointers in compact representations, reducing memory by 50% on 64-bit architectures while improving cache behavior. Unified resource types (Vulkan's VkBuffer, DirectX 12's ID3D12Resource) treat vertex buffers identically to other buffer types, enabling flexible reuse and compute-graphics interop. The modern API philosophy: **expose hardware capabilities directly** rather than maintaining complex driver-side state machines, shifting optimization responsibility to engine developers who profile actual workload patterns.

## Production libraries universally adopt vertex-centric representations

Three.js CircleGeometry exemplifies the industry standard pattern: **parameters stored only for debugging, actual geometry as static vertex data**. Constructor accepts radius, segments, thetaStart, and thetaLength, immediately computing vertices via trigonometry (vertex.x = radius × cos(segment), vertex.y = radius × sin(segment)), then storing results in Float32BufferAttribute arrays optimized for GPU transfer. No radius or angle parameters survive construction—the BufferGeometry base class contains only raw Float32Arrays of positions, normals, UVs, and triangle indices. Fan triangulation from a center vertex at (0,0,0) to rim vertices enables efficient rendering with gl_TRIANGLE_FAN or decomposition to indexed triangles.

CGAL's Polygon_2 class architecture reveals the **computational geometry philosophy of flexibility over optimization**. The template signature `Polygon_2<Traits, Container = std::vector<Point_2>>` allows user-selected storage containers, defaulting to std::vector for most applications. Critically, documentation explicitly states: **"computed values are not cached"**—every call to is_simple(), area(), orientation(), or bounded_side() triggers full O(n) or O(n log n) recomputation. Edge objects construct on-demand from adjacent vertices via edge iterators and circulators (circular iterators), never persisting in storage. CGAL distinguishes itself by providing both linear iterators (vertices_begin/end) and circular iterators (vertices_circulator) for elegant cyclic traversal, but no special "regular polygon" class exists—regularity must be maintained by user code generating appropriate vertex coordinates.

Unity and Unreal Engine employ **uniform Mesh representations** treating all geometry identically post-generation. Unity's Mesh class exposes public arrays (Vector3[] vertices, int[] triangles, Vector3[] normals, Vector2[] uv) with primitive generation via GameObject.CreatePrimitive(PrimitiveType) for standard shapes. No metadata survives indicating whether a mesh originated as a sphere, cube, or custom procedural algorithm—all become indistinguishable vertex+triangle arrays optimized for the rendering pipeline. Unreal's FPrimitiveSceneProxy and FMeshBatch architecture decouples component implementation from mesh submission, enabling aggressive caching of draw commands in retained-mode rendering. Both engines prioritize GPU upload format compatibility, where the in-memory representation directly mirrors VBO structure for zero-copy transfer.

Babylon.js diverges by **delegating polygon triangulation to external libraries**. The PolygonMeshBuilder class accepts user-provided Vector2 arrays defining boundaries in counter-clockwise order, then invokes the Earcut library for robust triangulation supporting holes and arbitrary shapes. This architectural choice trades built-in regular polygon generators for maximum flexibility—users must compute regular polygon vertices via manual trigonometry. The resulting mesh stores vertices, indices, normals, and UVs separately following standard WebGL buffer organization, with ExtrudePolygon() enabling 3D extrusion from 2D profiles. Open3D follows similar patterns with TriangleMesh factory methods (create_sphere, create_cylinder) producing pure vertex+triangle storage with optional computed properties like vertex_normals.

The universal design pattern: **generate once, store as vertices, render efficiently**. No system optimizes storage or processing specifically for regular polygons versus arbitrary polygons. Triangulation happens early—either at creation (Three.js, game engines) or on-demand (CGAL, Babylon.js with Earcut). The architectural consensus reflects hardware-driven design: vertex+triangle representation is the lingua franca of graphics hardware, making alternative representations fundamentally incompatible with modern rendering pipelines requiring immediate-mode buffer submission or retained-mode cached draw commands.

## Optimal storage strategies balance lazy evaluation with selective caching

CGAL's generic lazy evaluation scheme (Pion & Fabri, 2011) establishes the theoretical foundation: **delay computation until results affect program flow**, using interval arithmetic to filter cases where exact computation proves unnecessary. Expression directed acyclic graphs (DAGs) track computation dependencies, enabling recomputation at higher precision only when interval bounds cannot guarantee predicate correctness. Reference counting manages shared sub-expressions preventing redundant storage, while exception-based triggering invokes exact arithmetic only when fast floating-point filtering fails. This architecture **reduces computational cost by orders of magnitude** for geometric predicates in mesh processing pipelines.

The hybrid selective caching pattern emerges as best practice from surveying production implementations: **hot angles (frequently accessed) cached, cold angles computed on-demand**. For interior angles at vertices used in snapping operations, per-vertex caching with face-based invalidation provides optimal balance—store angle arrays at vertices, invalidate on position changes, recompute lazily on first access. For dihedral angles between faces used occasionally in 3D folding simulations, expression DAG storage shares normal computations between adjacent edges while caching evaluated results within nodes. The architecture separates topology (which edges connect which faces) from geometry (vertex positions determining angle values), enabling incremental updates that recompute only affected neighborhoods.

Research on dihedral angle-based tetrahedral mesh representations (ACM SIGGRAPH 2015) reveals that **complete 3D shapes can be defined purely by angular data**, enabling angle-primary storage with positions derived via spectral reconstruction. This inverted representation proves optimal for certain workflows: mesh compression (angles require less storage than coordinates), shape interpolation (angle spaces have better properties), and volumetric parameterization. The trade-off: encoding slower due to initial angle computation, decoding slower requiring spectral solves, but **smaller serialized size** particularly for smooth meshes where angles vary less than positions.

Granularity determines practical performance: per-vertex angle caching costs high memory but enables low-cost selective invalidation; per-face caching reduces memory with moderate invalidation cost; global angle sets minimize memory but force complete recomputation on any geometry change. **Dependency graphs prevent over-invalidation**—when vertex v moves, invalidate only angles at v and immediate neighbors rather than entire mesh. OpenMesh's traits-based customization allows compile-time selection: attributes allocated only when used, achieving zero overhead for unused angle storage through template metaprogramming and optional feature tags.

Incremental computation strategies prove essential for interactive editing. The handle-independent reduced model (HIRM) approach pre-computes propagation fields before user interaction, enabling system reconstruction time linear in vertices and independent of manipulation handle count. Mesh decimation frameworks use iterative edge collapse with priority queues, recomputing angles only for affected local neighborhoods rather than global recalculation. Batch update patterns accumulate modifications without intermediate recomputation, executing single passes after operation batches to eliminate redundant calculations. For massive meshes, GPU-accelerated patch-based decomposition (RXMesh architecture) achieves 10x+ speedups through parallel angle computation within shared memory with ribbon boundaries handling inter-patch communication.

## Architectural synthesis and design recommendations

The convergence of research and production practice yields clear design principles. **Primary recommendation: array-based vertex storage with lazy-evaluated angle properties**, leveraging symmetry group descriptors for regular polygons. Store vertices in std::vector or equivalent contiguous containers, compute edges via modulo indexing, generate angles on-demand with per-element caching for frequently accessed values. For GPU rendering, structure attributes as SoA in separate buffers, align to 16-byte boundaries minimum, use indexed triangle lists with vertex cache optimization (meshoptimizer library), and employ hardware instancing for repeated elements.

Symmetry exploitation provides algorithmic advantages: store only fundamental domain (1/2n vertices for D_n symmetry) plus group descriptor (⌈log₂(n)⌉ bits for order n), reconstruct full geometry by applying group operations. Interior angle formulas α = 180°(1 - 2/n) require single integer parameter n for complete specification. Dihedral angles for Platonic solids use lookup tables (40 bytes for 5 solids), while arbitrary convex polyhedra compute via sin(δ) = cos(π/n)/sin(π/f) requiring ~10 floating-point operations. **Pre-computation costs amortize for static meshes**, with typical break-even around 3-5 queries per angle—below this threshold, on-demand computation proves faster than cache management overhead.

For dynamic mesh applications, incremental update patterns minimize recomputation: maintain dependency graphs tracking which angles depend on which vertices, propagate invalidation only through affected subgraphs, batch modifications to trigger single recomputation pass rather than cascading updates. GPU-accelerated approaches using compute shaders achieve **10x+ speedup** for massive meshes through patch-based decomposition with parallel angle computation within shared memory, though requiring careful handling of patch boundaries via ribbon communication patterns.

**Decision matrix for representation selection:**

**Static meshes with frequent queries**: Pre-compute all angles at construction, store in per-element arrays, accept higher memory cost for consistent O(1) access latency.

**Dynamic meshes with infrequent queries**: Pure lazy evaluation without persistent caching, recompute on-demand from vertex data, minimize memory overhead.

**Mixed read/write workloads**: Hybrid selective caching with profiler-identified hot paths, promote frequently-accessed angles to cache while computing cold angles on-demand.

**Memory-constrained environments**: Expression DAGs with reference-counted sub-expressions, share computations between dependent properties, compress via symmetry group descriptors.

**Real-time rendering constraints**: Pre-computation during asset loading or level streaming, guarantee constant-time queries during frame rendering, trade loading time for runtime predictability.

The modern geometry processing pipeline thus crystallizes: generate regular polygons procedurally from symmetry group parameters (n for D_n), store vertices in GPU-friendly contiguous arrays, compute angles lazily with selective caching based on profiled access patterns, exploit symmetry for compression and accelerated computation, and leverage compute/mesh shaders for parallel procedural generation. **No production system stores angles redundantly** when derivable from vertex data, instead preferring to recompute the approximately 50-100 floating-point operations required for typical angle calculations over managing cache coherence across dynamic geometry modifications.

## Specialized architectural patterns for edge sequences

Edge-to-edge attachment in 3D folding operations requires **dihedral angle pre-computation tables indexed by polygon types**. When attaching an n-gon to an m-gon, the dihedral angle between their planes determines valid configurations. Geodesic dome construction exemplifies this pattern: icosahedron-based 3V frequency domes require pre-computed angle tables for the three distinct strut types, with bevel angles (180° - dihedral)/2 machined into hub connectors. Storage architecture: sparse matrix indexed by (face_type_i, face_type_j) containing dihedral angles, computed once during initialization via spherical trigonometry laws for vertices where three faces meet with angles a, b, c yielding dihedral angles A, B, C through spherical cosine laws.

Polygonal mesh generation algorithms benefit from **multi-resolution angle storage**—coarse levels cache approximate angles for rapid LOD selection, fine levels compute exact angles on-demand. The hierarchy mirrors spatial decomposition: octree or BVH nodes store bounding angle ranges, leaf elements compute precise values. Query pattern: traverse hierarchy to appropriate resolution, interpolate if necessary, cache results in working set. This architecture proves essential for adaptive tessellation where screen-space metrics determine subdivision: coarse angle bounds enable fast culling of distant or backfacing regions, precise angles computed only for visible high-detail regions.

**Symmetry group dictionaries** provide compact encoding for polygon families. Define base alphabet: C_n (cyclic rotation), D_n (dihedral), I (icosahedral), O (octahedral), T (tetrahedral) with subscript for order. Polygon specification becomes (symmetry_type, order, scale, orientation)—16 bytes total versus potentially kilobytes for explicit vertex arrays. Reconstruction: lookup group generator matrices from dictionary, apply to unit circle/sphere at specified scale, orient via quaternion or Euler angles. This representation enables efficient **parametric interpolation in symmetry space** for morphing animations while maintaining perfect regularity at keyframes.

Redundancy elimination algorithms (RACE - Redundant Array Computation Elimination) target loop-level angle computations in mesh processing. The pattern: detect when multiple loop iterations compute identical angles, cache first computation, return cached value for subsequent identical queries. Two-level identification combines array reference reuse detection with expression computation redundancy detection. Partial redundancy elimination applies code motion when angles needed on some execution paths but not others—hoist computation outside conditionals when safe. These compiler optimization techniques adapted to geometric processing reduce angle computation overhead by 30-50% in typical mesh processing loops.

The edge sequence to vertex generation pipeline for GPU execution follows specific patterns. **Parametric edge buffer representation**: store compact Bezier cubic control points (4 × float4 = 64 bytes), tessellation level (uint16), edge type identifier (uint16), and attributes like color/thickness (float4 = 16 bytes), totaling ~84 bytes per edge descriptor. **Compute shader expansion**: workgroups process one edge each with local_size_x threads evaluating parametric functions at t = threadID / (threads - 1), writing to dense SoA vertex buffers (position float3, tangent float3, parameter float2 = 32 bytes per vertex). **Instance rendering**: submit generated vertex buffers via glDrawElementsInstanced or vkCmdDrawIndexed with per-instance transforms from separate buffers or uniform arrays. This three-stage pipeline achieves 100+ million vertices/second generation on modern GPUs.

## Conclusion: convergence toward hardware-aware simplicity

The research synthesis reveals architectural convergence toward **radical simplicity in storage with sophisticated computation**. Production systems abandoned complex data structures maintaining redundant geometric properties in favor of minimal vertex+topology representations where all derived quantities compute on-demand with aggressive caching only for proven hotspots. The half-edge structure provides elegant topology representation, contiguous arrays deliver optimal cache behavior, and lazy evaluation with expression DAGs minimizes wasted computation.

Symmetry group theory bridges discrete mathematics and practical optimization—storing log₂(n) bits of group structure enables reconstruction of n vertices with perfect regularity, while orbifold notation provides 2-6 character specifications of complete symmetry classes. Interior angles reduce to single-parameter formulas, dihedral angles admit closed-form solutions for regular cases and fast trigonometric computation for general cases. No angle storage proves necessary when geometric computation costs ~50-100 floating-point operations while cache management overhead exceeds this for infrequently-accessed properties.

GPU architecture dictates SoA layouts for coalesced memory access, 16-byte alignment for cache lines, and compute/mesh shader procedural generation over CPU-side computation with PCIe transfer bottlenecks. Modern APIs (Vulkan, DirectX 12, Metal, WebGPU) expose explicit memory management requiring integer index handles rather than pointers, enabling compact 50% memory reductions on 64-bit systems. Hardware instancing achieves 10-100x draw call reduction while mesh shaders replace legacy tessellation/geometry pipelines with flexible on-chip generation.

The ultimate architectural principle: **separation of concerns across three independent layers**. Combinatorial topology (half-edge connectivity) changes rarely and admits compact index-based encoding. Geometric embedding (vertex coordinates) changes frequently but requires only O(n) storage for n vertices. Derived properties (angles, areas, normals) should never persist redundantly—compute from topology+geometry with caching only for hot paths. This layered architecture maximizes flexibility, minimizes memory, and enables independent optimization of each layer for its characteristic access patterns and modification frequencies. The future points toward increased GPU-side procedural generation, neural network learned geometric representations, and quantum-inspired group-theoretic compressions, but the foundation remains: store minimally, compute intelligently, cache selectively.