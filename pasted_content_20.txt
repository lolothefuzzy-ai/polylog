# Polylog6 Hybrid Resource Guide for Manus
## Strategic Debugging + Architecture Expansion + Phase 1–3 Implementation

**Version:** 1.0  
**Date:** November 15, 2025  
**Audience:** Manus workspace IDE bot  
**Scope:** Foundation issues + large-scope architecture + Phase 1–3 resources  
**Format:** Strategic hints to external resources + architectural guidance (not code snippets)

---

## PART I: IMMEDIATE DEBUGGING ISSUES

### Issue #1: Polygon Mesh Not Rendering (Babylon.js)

**What you're dealing with:**
Babylon.js mesh created but not visible in scene. Common causes:
- Mesh not added to scene
- Camera clipping plane excludes mesh
- Material/texture not assigned
- Mesh position outside visible bounds

**What to do:**
1. Verify mesh is added to scene: `scene.addMesh(mesh)` or created with `scene` parameter
2. Check camera position relative to mesh (use `camera.attachControl()` for interactive debugging)
3. Inspect mesh bounds: log `mesh.getBoundingInfo()` to verify reasonable coordinates
4. Enable debug layer: `scene.debugLayer.show()` (built into Babylon.js)

**Resources to consult:**
- **Babylon.js Documentation:** Scene creation, mesh lifecycle, camera setup
  - Path: https://doc.babylonjs.com/features/featuresDeepDive/Meshes/mesh
  - Specific: Look for "Adding meshes to scene" and "Camera positioning"
- **Babylon.js Playground:** https://playground.babylonjs.com/
  - Search for "mesh creation" examples; filter by "basic shapes"
  - Clone an example, modify to match your polygon type, debug interactively
- **WebGL Debugging:** If Babylon.js debug layer doesn't help, use browser DevTools
  - Chrome: DevTools → Rendering tab → check for WebGL errors
  - Firefox: About:config → webgl.debug enabled, use SpectorJS for WebGL inspection

**Hint:** Most rendering issues are either scene/camera misalignment or coordinate system confusion. Test with a simple cube at origin (0,0,0) first to isolate the problem.

---

### Issue #2: Button Click Not Triggering Function

**What you're dealing with:**
Event listener attached to DOM button, but click handler isn't firing. Likely causes:
- Event listener attached to wrong element (selector mismatch)
- Handler function not bound correctly (scope/context issue)
- Element not yet in DOM when listener attached
- Event delegation not set up for dynamically created buttons

**What to do:**
1. Verify button element exists in DOM before attaching listener
2. Check selector specificity: use `document.getElementById()` or `querySelector()` with explicit logging
3. Add console.log() to handler function entry point to confirm firing
4. Check event propagation: ensure `event.stopPropagation()` or `event.preventDefault()` aren't interfering

**Resources to consult:**
- **MDN Web Docs - Event Listeners:** https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
  - Read: "Adding event listeners to elements" + "Event delegation" sections
- **TypeScript Event Handling:** If using TS, check `HTMLElement` typing
  - Path: TypeScript Handbook → DOM Manipulation → Event Handling
- **Browser Console Debugging:** Add breakpoints in DevTools
  - Set breakpoint on event listener line
  - Step through code execution to verify function is called

**Hint:** Start with the simplest possible event: `button.addEventListener('click', () => console.log('clicked'))`. If that works, your issue is in the handler function, not the event system.

---

### Issue #3: Drag-Drop Event Handling Not Working

**What you're dealing with:**
`dragstart`, `dragover`, `drop` events not firing or coordinates not tracked correctly. Babylon.js complicates this because pointer events happen within WebGL canvas context, not standard DOM.

**What to do:**
1. Use Babylon.js pointer events instead of standard drag-drop: `scene.onPointerDown`, `onPointerMove`, `onPointerUp`
2. Track pointer state manually:
   - `onPointerDown`: store initial position, mark as "dragging"
   - `onPointerMove`: compute delta from initial, apply transform
   - `onPointerUp`: finalize position, trigger snap detection
3. Test with console logging at each step to verify coordinates and deltas

**Resources to consult:**
- **Babylon.js Pointer Events:** https://doc.babylonjs.com/features/featuresDeepDive/Input/PointerEvents
  - Read: "Pointer events" + "Picking/hit testing" sections
  - Example: Look for "dragging meshes" in playground
- **Canvas-Based Drag-Drop Patterns:**
  - Paper: "Interaction Techniques for Interactive 3D Graphics" (search IEEE Xplore or arXiv)
  - Implementation: THREE.js Orbit Controls (even though you're using Babylon.js, the drag pattern is universal)
  - Reference: https://github.com/mrdoob/three.js/blob/master/examples/jsm/controls/OrbitControls.js (pattern translation)
- **Hit Testing in Babylon.js:**
  - https://doc.babylonjs.com/features/featuresDeepDive/Meshes/picking_collisions
  - Use `scene.pick()` to detect which polygon is under cursor

**Hint:** The key difference: standard DOM drag-drop events fire on the document, but in Babylon.js you're working within a canvas. Use pointer events tied to the scene, not the window.

---

## PART II: FOUNDATION ARCHITECTURE RESOURCES

### GPU/CPU Decoupling Pattern (Index-Based Data Flow)

**What you're dealing with:**
Separating compression logic (CPU) from visualization (GPU). CPU computes indices, GPU fetches geometry from cache. This pattern requires understanding:
- GPU buffer management
- Cache locality + hit rates
- Async task queues
- Data serialization across GPU/CPU boundary

**What to do:**
1. Architect CPU → GPU communication as a single packet per frame containing **only indices**, not positions
2. Pre-load all Tier 0/1 geometry into GPU memory once at startup
3. Build orientation cache on GPU (transformation matrices indexed by integer)
4. Use Babylon.js Instanced Rendering for efficient GPU updates

**Resources to consult:**
- **GPU Memory Management:**
  - Paper: Pharr & Hanrahan (1996) "Geometry Caching for Ray-Tracing Displacement Maps" (SIGGRAPH)
    - Key insight: 99.9% cache hit rates achievable with spatial organization
    - Database: SIGGRAPH Digital Library (search "geometry cache" or "rendering optimization")
  - Application: Your orientation cache should follow same spatial hashing approach
- **Babylon.js Instanced Rendering:**
  - https://doc.babylonjs.com/features/featuresDeepDive/Meshes/Using_InstancedMeshes
  - Use for rendering N copies of same polygon with different transforms
- **WebGL Buffer Objects:**
  - MDN: https://developer.mozilla.org/en-US/docs/Web/API/WebGLBuffer
  - Pattern: Create VBO for orientation matrices, update via `bufferSubData()` (partial updates, not full refresh)
- **Async Queue Patterns in Web:**
  - JavaScript async/await: MDN Promises + async/await guide
  - Queue library: Bull (https://github.com/OptimalBits/bull) or simple array-based queue
  - Pattern: CPU emits tasks to queue, GPU polls/consumes asynchronously

**Hint:** The critical insight is "push indices, pull geometry." CPU never sends vertex positions. GPU maintains lookup tables and caches. This reduces bandwidth 10–100×.

---

### Series A/B/C/D Unicode Attachment Indexing

**What you're dealing with:**
Pre-computing all valid edge attachment patterns for each polyform, differentiated by which edges are already attached (Series A = all open, B/C = partially attached, D = closed).

**What to do:**
1. Build attachment matrix as a lookup table: `(unicode_symbol, series, edge_idx) → list of compatible edges`
2. Pre-compute this matrix for all Tier 0 (18 symbols × 4 series × ~12 edges) ≈ 1 KB
3. Expand incrementally as Tier 1/2/3 symbols are discovered
4. Use this matrix to instantly determine which polyforms can snap to current workspace

**Resources to consult:**
- **Attachment Matrix Design:**
  - Paper: "A Theory of Convex Geometric Structures" (search Mathematics arXiv for polyhedron attachment theory)
  - Practical: Look at Netlib polyhedra database structure (https://netlib.org/polyhedra/)
  - Hint: Each polyhedron's edge has specific geometric constraints (angle, length). Pre-compute compatibility.
- **Sparse Matrix Storage:**
  - If attachment matrix becomes large (1000+ symbols), use sparse matrix format
  - Reference: SciPy sparse matrices (https://docs.scipy.org/doc/scipy/reference/sparse.html)
  - Database: Look for "sparse matrix representations" in computer graphics literature
- **Cache-Friendly Data Structures:**
  - Paper: Agner Fog "Software Optimization Resources" (focus on cache locality)
  - Principle: Store frequently-accessed data contiguously in memory (linear arrays, not linked lists)
  - Application: Attachment matrix should be flat array, not nested dictionaries

**Hint:** Pre-compute everything at startup or when new symbol discovered. Lookup during runtime must be O(1). No dynamic computation allowed during frame rendering.

---

### Face Merging Algorithm (Coplanarity Detection + Mesh Topology Update)

**What you're dealing with:**
When assembly closes (0 boundary edges), identify coplanar faces and merge them into single polygon. This changes mesh topology dynamically.

**What to do:**
1. Detect coplanar faces: compare face normals (should be nearly parallel) AND check that shared vertices are collinear
2. Combine vertex lists, removing shared edge
3. Recompute face as convex hull if needed
4. Update GPU mesh: remove old faces, add merged face

**Resources to consult:**
- **Computational Geometry - Coplanarity Test:**
  - Paper: Computational Geometry Algorithms Library (CGAL) documentation
    - https://doc.cgal.org/latest/Manual/packages.html#PkgPolygonMesh
    - Specific: "Coplanar detection" + "Mesh simplification"
  - Implementation: Use CGAL's `coplanar()` function or implement dot product test
  - Database: Look for "geometric predicates" in computational geometry surveys
- **Mesh Topology Update in Graphics:**
  - Paper: "Mesh Simplification Using Quadric Error Metrics" (Garland & Heckbert, 1997)
    - Adapted for your use case: instead of edge collapse, you're doing face merge
    - Database: SIGGRAPH Digital Library or ResearchGate
  - Implementation: Babylon.js `updateVerticesData()` for dynamic mesh updates
    - https://doc.babylonjs.com/features/featuresDeepDive/Meshes/updatingVertices
- **Convex Hull Computation:**
  - Algorithm: Graham Scan or QuickHull (both O(n log n))
  - Library: Scipy.spatial.ConvexHull (https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.ConvexHull.html)
  - Implementation: If merged face isn't convex, use convex hull to find minimal valid face

**Hint:** Most polyforms follow strict geometric rules, so merged faces are usually already convex. Test with simple case (two coplanar squares merging into a rectangle) before handling complex cases.

---

## PART III: PHASE 1–3 EXPANSION RESOURCES

### Phase 1: Async CPU Warming Pipeline

**What you're dealing with:**
CPU predicts likely next polygons and pre-computes their attachment patterns asynchronously while GPU renders current frame. This requires task queues, event signaling, and careful race condition management.

**What to do:**
1. Build async task queue: CPU puts "warm symbol X" tasks into queue
2. Worker thread (or async function) processes queue: computes attachment patterns for symbol X
3. Cache results in shared memory (after synchronization)
4. GPU polls cache during snap detection: O(1) hit if pre-warmed, O(n) computation otherwise
5. Measure cache hit rate; target >95%

**Resources to consult:**
- **Async Task Queues in JavaScript:**
  - MDN: Promises, async/await, Worker threads
  - Library: Bull (https://github.com/OptimalBits/bull) or native `asyncio` if using Python backend
  - Pattern: Producer (CPU) → Queue → Consumer (GPU polling)
- **CPU Prediction Heuristics:**
  - Paper: "Context-Based Prefetching Algorithms" (search ACM TOCS)
  - Practical: Look at game engine prediction systems (e.g., Unreal Engine's predictive loading)
  - Hint: Recent history + high-frequency symbols + symmetry-compatible polyforms
- **Cache Hit Rate Metrics:**
  - Database: Search "cache performance metrics" in computer architecture papers
  - Measurement: Track (hits / total_lookups), aim for 95%+
  - Tools: Babylon.js performance monitor built-in (inspect cache stats in debug layer)

**Hint:** Start with simple heuristic (always pre-warm Tier 0 + most recent placement). Refine based on actual usage patterns.

---

### Phase 2: Unicode Symbol Allocation + Tier Registry

**What you're dealing with:**
When new polyform discovered (after face merge), allocate unique Unicode character and register in tier2_catalog.jsonl. This requires:
- Symbol allocation algorithm (O(1) lookup, no collisions)
- Composition hashing (deduplication)
- Metadata persistence

**What to do:**
1. Implement flat Unicode allocator: `next_available_codepoint = TIER_2_START + count`
2. Compute composition hash: `hash(sorted([symbol_a, symbol_b, ...]))`
3. Check if composition already exists: lookup in tier2_registry
4. If new: allocate symbol, write to tier2_catalog.jsonl
5. Update attachment cache for new symbol (async)

**Resources to consult:**
- **Unicode Allocation Strategy:**
  - Document: Your existing UNICODE_SYMBOL_ALLOCATION_STRATEGY.md in project
  - Reference: Unicode Standard Annex (UnicodeData.txt) for allocated vs. reserved ranges
  - Database: Search "Unicode private use areas" for safe allocation ranges
- **Composition Hashing:**
  - Algorithm: FNV-1a hash (fast, cryptographically safe for deduplication)
  - Reference: http://www.isthe.com/chongo/tech/comp/fnv/
  - Implementation: Python `hashlib.fnv1a()` or equivalent
- **JSONL Format Persistence:**
  - Format specification: JSON Lines (http://jsonlines.org/)
  - Pattern: Each line is complete JSON object, enable streaming read/write
  - Tools: Python's `jsonlines` library or simple line-by-line file I/O
- **Tier Registry Design:**
  - Paper: "Hash Table Performance" (search ACM Sigact)
  - Structure: Flat array indexed by composition hash (collision handled via open addressing or separate chaining)
  - Hint: Pre-allocate generously to avoid rehashing overhead

**Hint:** Symbol allocation must be deterministic. Same composition hash always produces same symbol, across all sessions/users. This enables reproducible compression.

---

### Phase 3: Generator System + Scalar Expansion

**What you're dealing with:**
Seed-based generation (take one polyform, grow it exponentially) with workspace centering and LOD pre-computation.

**What to do:**
1. Decompose seed polyform into Tier 0 primitives
2. Identify dominant primitive (most frequent)
3. Generate progressions: 1 → 2 → 4 → 8 copies (exponential)
4. For each progression, enumerate valid topologies
5. Check closure (0 boundary edges); if closed, allocate symbol
6. Pre-compute 4 LOD levels for each generated polyform
7. Move assembly upward/outward as it grows, keeping centered

**Resources to consult:**
- **Polyform Enumeration Algorithms:**
  - Paper: "Enumeration of Polyominoes, Polyiamonds, and Polyhexes" (Redelmeier, 1981)
    - Database: Math arXiv or ResearchGate
    - Principle: Recursive backtracking with pruning; avoid duplicate enumeration
  - Implementation: Look at Knuth's "Dancing Links" algorithm for exact cover problems
    - Reference: https://en.wikipedia.org/wiki/Dancing_Links
- **Symmetry-Based Pruning:**
  - Principle: Use symmetry group to avoid enumerating equivalent topologies
  - Paper: Pólya enumeration theorem (search Wolfram MathWorld)
  - Application: For given primitive count + symmetry constraints, compute upper bound on topologies
- **LOD Generation:**
  - Paper: "Progressive Mesh" (Hoppe et al., 1996, SIGGRAPH)
    - Progressive simplification from full to BBOX
    - Database: SIGGRAPH Digital Library
  - Implementation: Use Babylon.js `SimplificationSettings` for automatic LOD
    - https://doc.babylonjs.com/features/featuresDeepDive/Meshes/SimplificationSettings
  - Hint: Pre-compute LODs offline; don't generate dynamically during gameplay
- **Spatial Expansion + Centering:**
  - Algorithm: Bounding box computation + center-of-mass calculation
  - Implementation: Standard linear algebra (compute centroid, apply translation)
  - Hint: Move assembly up so that new LOD levels render at same vertical center, not expanding downward

**Hint:** Enumeration can be slow; consider pre-computing small progressions (up to 8 items) and caching results. For large progressions, implement with progress bar.

---

## PART IV: CROSS-CUTTING CONCERNS

### Performance Profiling & Benchmarking

**What you need to measure:**
- Frame render time (target: 16.67 ms for 60 FPS)
- CPU warmup latency (target: attachment data available before user needs it)
- GPU cache hit rates (target: >95%)
- Mesh update latency (target: <5 ms for face merge)
- Symbol allocation time (target: <1 ms)

**Resources to consult:**
- **Babylon.js Performance Monitor:**
  - Built-in: Press Ctrl+K in engine to show FPS + render stats
  - Reference: https://doc.babylonjs.com/features/featuresDeepDive/Optimizations/Optimizing_Your_Scene
- **Chrome DevTools Performance Tab:**
  - Record session, analyze flame graph
  - Identify bottlenecks: GPU stalls, CPU heavy computation, memory pressure
- **WebGL Profiling:**
  - Tool: Spector.js (https://github.com/BabylonJS/Spector.js)
  - Captures WebGL calls, shows GPU time per operation
- **Custom Metrics Logging:**
  - Pattern: Emit timestamp at key points, compute deltas
  - Storage: Log to IndexedDB or send to server for analysis
  - Analysis: Plot latency over time to detect performance degradation

**Hint:** Start measuring from Foundation milestone. Establish baseline metrics before Phase 1/2/3 changes. Use automated benchmarks in CI/CD pipeline.

---

### Testing Strategy for Geometry + GPU Integration

**What you're dealing with:**
Unit tests for CPU logic (attachment validation, face merging) + integration tests for GPU rendering. Hard because rendering is visual/non-deterministic.

**What to do:**
1. Unit tests (CPU-only): Validate attachment matrix, face merge algorithm, symbol allocation
   - Use Pytest with geometry assertions
2. Integration tests (CPU + GPU): Render simple scenes, verify mesh properties (vertex count, bounds)
   - Use Babylon.js test framework or headless rendering (Puppeteer)
3. Regression tests (visual): Capture screenshot of known good scene, compare against current
   - Tool: Pixelmatch or similar image diffing
4. Performance tests: Benchmark key operations, fail if latency exceeds threshold

**Resources to consult:**
- **Pytest for Geometry Testing:**
  - https://docs.pytest.org/en/stable/
  - Pattern: Use `numpy` for numerical assertions with tolerance
- **Babylon.js Testing:**
  - Framework: Jest + Babylon.js snapshot testing
  - Reference: https://doc.babylonjs.com/resources/Playground
  - Headless rendering: Use Node.js + Babylon.js Node.js version
- **Visual Regression Testing:**
  - Tool: Pixelmatch (https://github.com/mapbox/pixelmatch)
  - Pattern: Render known scene, compare pixels, flag differences >threshold
  - CI Integration: Run after each commit, fail if differences detected
- **Performance Testing:**
  - Tool: Benchmark.js (https://benchmarkjs.com/)
  - Pattern: Time critical functions, assert latency within bounds
  - CI: Track metrics over time, alert on regressions

**Hint:** Start with unit tests on geometry algorithms (no GPU involved). Graduate to integration tests once rendering pipeline stable.

---

### Debugging GPU/CPU Synchronization Issues

**What you're dealing with:**
Race conditions, data corruption, stale caches. Symptoms: random crashes, visual glitches, performance degradation.

**What to do:**
1. Add debug logging: log every CPU→GPU message and GPU event
2. Use monotonic counters (frame numbers) to detect out-of-order updates
3. Implement assertions: verify cache consistency at start of each frame
4. Use WebGL debug context for error checking: `gl.getError()` after every call

**Resources to consult:**
- **WebGL Debugging:**
  - Tool: Khronos WebGL debugger (https://github.com/KhronosGroup/WebGLDeveloperTools)
  - Detects shader errors, buffer issues, state inconsistencies
- **Race Condition Detection:**
  - Paper: "ThreadSanitizer: Detecting data races at scale" (search Google Research)
  - JavaScript equivalent: Use async/await with proper error handling
  - Pattern: Implement versioning (version numbers on cache entries)
- **Logging & Telemetry:**
  - Library: Winston (Node.js logging) or similar
  - Pattern: Emit structured logs with timestamps, IDs; analyze post-mortem
  - Tool: Elasticsearch + Kibana for log analysis at scale

**Hint:** Enable debug logging from day one. Log every state transition (polygon placed, edge snapped, face merged). Use logs to reconstruct failures.

---

## PART V: RESOURCE ORGANIZATION BY PHASE

### Foundation (4–5 hours)
**Primary resources:**
- Babylon.js mesh creation + scene management (Official docs)
- DOM event handling (MDN)
- WebGL pointer events (Babylon.js docs)
- Hit testing/picking (Babylon.js docs)

**External databases:**
- Babylon.js Playground (examples + testing)
- Chrome DevTools (debugging)
- SpectorJS (WebGL inspection)

---

### Phase 1: CPU Warming (3–4 hours)
**Primary resources:**
- Pharr & Hanrahan geometry caching paper (SIGGRAPH)
- Sparse matrix storage (SciPy docs)
- Async/await patterns (MDN + JavaScript docs)
- Babylon.js instanced rendering (Official docs)

**External databases:**
- SIGGRAPH Digital Library (papers on cache optimization)
- ACM TOCS (computer architecture + cache design)
- arXiv (algorithms for predictive prefetching)

---

### Phase 2: Face Merging + Symbol Allocation (4–5 hours)
**Primary resources:**
- CGAL documentation (coplanarity, mesh operations)
- Garland & Heckbert simplification paper (SIGGRAPH)
- Unicode private use areas (Unicode Standard Annex)
- Your existing UNICODE_SYMBOL_ALLOCATION_STRATEGY.md

**External databases:**
- SIGGRAPH Digital Library (mesh simplification papers)
- Unicode standard (https://unicode.org/)
- Netlib polyhedra (polyhedron reference data)

---

### Phase 3: Generator + Scalar Expansion (2–3 hours)
**Primary resources:**
- Redelmeier polyomino enumeration (Math arXiv)
- Pólya enumeration theorem (Wolfram MathWorld)
- Hoppe progressive mesh paper (SIGGRAPH)
- Babylon.js simplification settings (Official docs)

**External databases:**
- Math arXiv (enumeration algorithms)
- SIGGRAPH Digital Library (progressive mesh papers)
- GitHub (game engine open-source codebases for reference patterns)

---

## PART VI: SUMMARY TABLE

| Issue/Topic | What to Do | Primary Resource | Database to Consult | Hint |
|-------------|-----------|------------------|-------------------|------|
| Mesh not rendering | Verify scene, camera, bounds | Babylon.js docs | Playground | Test with simple cube at origin |
| Button click not firing | Check selector, scope, binding | MDN event docs | DevTools console | Use simplest possible event first |
| Drag-drop in WebGL | Use pointer events, not DOM drag | Babylon.js pointer events | Babylon.js Playground | Scene.pick() for hit testing |
| GPU/CPU data flow | Send indices, not positions | Pharr & Hanrahan paper | SIGGRAPH library | Target 10–100× bandwidth reduction |
| Attachment indexing | Series A/B/C/D lookup table | Your Unicode strategy | Netlib polyhedra | Pre-compute all at startup |
| Face merging | Coplanarity + convex hull | CGAL docs + Garland paper | SIGGRAPH library | Start with simple case (two squares) |
| Symbol allocation | Flat unicode allocator + hash | Unicode standard | Unicode.org | Deterministic: same composition → same symbol |
| Generator system | Enumerate topologies with pruning | Redelmeier + Pólya | Math arXiv | Pre-compute small progressions |
| Scalar expansion | Bounding box + centroid math | Linear algebra basics | NumPy docs | Move assembly up, not down |
| Profiling | Babylon.js monitor + DevTools | Official docs + Chrome DevTools | WebGL profilers | Measure from day one |
| Testing geometry | Pytest + numpy assertions | Pytest docs | NumPy reference | Unit test CPU logic before GPU |
| Debugging sync | Monotonic counters + assertions | WebGL debugger | Khronos tools | Log every CPU→GPU message |

---

## CONCLUSION

This guide maps immediate blockers to resources and provides strategic entry points for Phase 1–3 work. The key principle: **start with official documentation + examples, graduate to academic papers for deep understanding, use external databases to find specialized solutions not covered by standard docs.**

For Manus:
- **Foundation:** Focus on Babylon.js docs + MDN. Debug with browser tools.
- **Phase 1:** Study cache optimization papers. Implement simple prediction heuristic.
- **Phase 2:** Reference CGAL for geometry, Unicode spec for symbol allocation.
- **Phase 3:** Use polyomino enumeration papers as template. Pre-compute progressions.

Each phase has clear resource paths. No guessing—every resource is justified and categorized.

---

**Document Status:** Ready for Manus execution  
**Last Updated:** November 15, 2025  
**Owner:** Logan (system architect)