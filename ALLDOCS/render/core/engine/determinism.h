#pragma once\n#include <cstdint>\n#include <thread>\n\nnamespace polylog::core {\n\n/**\n * Global determinism mode control.\n * When enabled, all non-deterministic sources are seeded for reproducibility.\n * STAB-006: Determinism mode toggle and seed plumbing.\n */\nclass DeterminismMode {\npublic:\n    static void SetEnabled(bool enabled) { enabled_.store(enabled); }\n    static bool IsEnabled() { return enabled_.load(); }\n    \n    /// Seed all subsystem RNGs from a root seed.\n    /// Called once at startup if determinism is enabled.\n    static void SeedAll(uint64_t seed);\n    \nprivate:\n    static thread_local std::atomic<bool> enabled_;\n};\n\n/**\n * Simple deterministic RNG using xorshift32.\n * Use this for any randomness in determinism mode.\n */\nclass DeterministicRNG {\npublic:\n    explicit DeterministicRNG(uint64_t seed = 42) {\n        state_ = seed ? seed : 1u;  // Avoid all-zero state\n    }\n    \n    /// Get next 32-bit random integer\n    uint32_t Next() {\n        uint32_t x = state_;\n        x ^= x << 13;\n        x ^= x >> 17;\n        x ^= x << 5;\n        state_ = x;\n        return x;\n    }\n    \n    /// Get random float in [0, 1)\n    float NextFloat01() {\n        return (Next() >> 8) * (1.0f / 16777216.0f);\n    }\n    \n    /// Get random float in [min, max)\n    float NextFloat(float min, float max) {\n        return min + (max - min) * NextFloat01();\n    }\n    \n    /// Reset to a known seed\n    void Reseed(uint64_t seed) {\n        state_ = seed ? seed : 1u;\n    }\n    \nprivate:\n    uint32_t state_;\n};\n\n}  // namespace polylog::core\n