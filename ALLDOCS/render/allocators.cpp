#include "allocators.h"\n#include <algorithm>\n#include <cstring>\n\nnamespace polylog::render {\n\nBuddyAllocator::BuddyAllocator(size_t size) : capacity_(size) {\n    // Initialize free blocks list\n    free_blocks_.push_back(new uint8_t[size]);\n}\n\nBuddyAllocator::~BuddyAllocator() {\n    for (auto block : free_blocks_) {\n        delete[] static_cast<uint8_t*>(block);\n    }\n}\n\nvoid* BuddyAllocator::Allocate(size_t size) {\n    if (free_blocks_.empty()) return nullptr;\n    \n    // Find a free block large enough\n    for (auto it = free_blocks_.begin(); it != free_blocks_.end(); ++it) {\n        void* block = *it;\n        free_blocks_.erase(it);\n        \n        total_allocated_ += size;\n        peak_allocated_ = std::max(peak_allocated_.load(), total_allocated_.load());\n        \n        UpdateFragmentation();\n        return block;\n    }\n    \n    return nullptr;\n}\n\nvoid BuddyAllocator::Free(void* ptr) {\n    if (ptr == nullptr) return;\n    \n    free_blocks_.push_back(ptr);\n    UpdateFragmentation();\n}\n\nbool BuddyAllocator::Defragment() {\n    // Simple defrag: compact free blocks if possible\n    if (free_blocks_.size() <= 1) return false;\n    \n    // Placeholder: actual defragmentation would be more complex\n    UpdateFragmentation();\n    return true;\n}\n\nvoid BuddyAllocator::UpdateFragmentation() {\n    // Fragmentation = (wasted space) / (total capacity)\n    size_t wasted = capacity_ - total_allocated_;\n    fragmentation_ = static_cast<float>(wasted) / static_cast<float>(capacity_);\n    fragmentation_ = std::max(0.0f, std::min(1.0f, fragmentation_));\n}\n\n}  // namespace polylog::render\n
