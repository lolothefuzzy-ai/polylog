#pragma once\n#include <cstddef>\n#include <cstdint>\n#include <vector>\n#include <atomic>\n\nnamespace polylog::render {\n\n/**\n * STAB-021: Linear allocator for per-frame allocations.\n * No fragmentation; simple reset per frame.\n */\nclass LinearAllocator {\npublic:\n    LinearAllocator(size_t size) : capacity_(size), used_(0) {\n        buffer_ = new uint8_t[size];\n    }\n    ~LinearAllocator() { delete[] buffer_; }\n    \n    void* Allocate(size_t size, size_t alignment = 16) {\n        // Align current pointer\n        uintptr_t addr = reinterpret_cast<uintptr_t>(buffer_ + used_);\n        uintptr_t aligned = (addr + alignment - 1) & ~(alignment - 1);\n        size_t offset = aligned - addr;\n        \n        used_ += offset + size;\n        if (used_ > capacity_) return nullptr;\n        \n        return reinterpret_cast<void*>(aligned);\n    }\n    \n    void Reset() { used_ = 0; }\n    float GetFragmentation() const { return 0.0f; }\n    size_t GetUsed() const { return used_; }\n    size_t GetCapacity() const { return capacity_; }\n    \nprivate:\n    uint8_t* buffer_;\n    size_t capacity_;\n    std::atomic<size_t> used_;  // Thread-safe for diagnostic reads\n};\n\n/**\n * STAB-021: Buddy allocator for pooled long-lived resources.\n * Supports fragmentation reporting and defragmentation.\n */\nclass BuddyAllocator {\npublic:\n    BuddyAllocator(size_t size);\n    ~BuddyAllocator();\n    \n    void* Allocate(size_t size);\n    void Free(void* ptr);\n    \n    float GetFragmentation() const { return fragmentation_; }\n    bool Defragment();  // Non-blocking; returns true if work done\n    \n    size_t GetTotalAllocated() const { return total_allocated_; }\n    size_t GetPeakAllocated() const { return peak_allocated_; }\n    \nprivate:\n    size_t capacity_;\n    float fragmentation_ = 0.0f;\n    std::atomic<size_t> total_allocated_{0};\n    std::atomic<size_t> peak_allocated_{0};\n    \n    void UpdateFragmentation();\n};\n\n}  // namespace polylog::render\n